\section{Generators}

The C++ standard offers three types of generators: fill with copies of a value, fill with results of invoking a generator functor and fill with sequentially increasing values.

\subsection{\texorpdfstring{\cpp{std::fill}, \cpp{std::generate}}{\texttt{std::fill}, \texttt{std::generate}}}

The \cpp{std::fill} algorithm fills a range by consecutively assigning the given value to each element.
The \cpp{std::generate} algorithm fills a range by consecutively assigning the result of the provided generator.

\cppversions{\texttt{fill}, \texttt{generate}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{\texttt{forward\_range}}{N/A}{\texttt{generator}}

The generator provided to \cpp{std::generate} can be a non-regular function since \cpp{std::generate} guarantees strict left-to-right evaluation.

\begin{box-note}
\footnotesize Example of using \cpp{std::fill} and \cpp{std::generate}.
\tcblower
\cppfile{code_examples/algorithms/generate_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::fill_n}, \cpp{std::generate_n}}{\texttt{std::fill\_n}, \texttt{std::generate\_n}}}

The \cpp{std::fill_n} and \cpp{std::generate_n} are variants of \cpp{std::fill} and \cpp{std::generate} that operate on ranges specified using the start iterator and number of elements. This behaviour allows the algorithms to be used with iterator adapters, such as \cpp{std::back_inserter}.

\cppversions{\texttt{fill\_n, generate\_n}}{\CC98}{\CC20}{\CC17}{\CC20}
\constraints{\texttt{output\_iterator}}{\texttt{forward\_iterator}}{N/A}{\texttt{generator}}

\begin{box-note}
\footnotesize Example of using \cpp{std::fill_n} and \cpp{std::generate_n}.
\tcblower
\cppfile{code_examples/algorithms/fill_n_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::iota}}{\texttt{std::iota}}}

The \cpp{std::iota} generates elements by consecutively assigning the result of applying the prefix \cpp{operator++}, starting with the initial value.

\cppversions{\texttt{iota}}{\CC11}{\CC20}{N/A}{\CC23}
\constraints{\texttt{forward\_range}}{}{}{}

\begin{box-note}
\footnotesize Example of using \cpp{std::iota}.
\tcblower
\cppfile{code_examples/algorithms/iota_code.h}
\end{box-note}

Notably, the \cpp{std::iota} algorithm is also an outlier in the support added with the C++20 standard. The std::iota algorithm did not receive a range version. However, we do have access to an iota view.

\begin{box-note}
\footnotesize Example of using \cpp{std::iota}.
\tcblower
\cppfile{code_examples/algorithms/iota_view_code.h}
\end{box-note}


Iota is an outlier when it comes to C++20 std::ranges support. C++20 introduced the lazy view version std::views::iota, and we will only get the eager range version of the algorithm in C++23.



The std::iota algorithm will generate elements by consecutively applying the prefix increment operator, starting with the initial value.

\begin{box-note}
\begin{cppcode}
std::vector<int> data(11, 0);

std::iota(data.begin(), data.end(), -5); 
// data == { -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 }

std::vector<int> out;
std::ranges::transform(std::views::iota(1, 10), std::views::iota(5), 
                       std::back_inserter(out), std::plus<>{});
// out == { 6, 8, 10, 12, 14, 16, 18, 20, 22 }
\end{cppcode}
\end{box-note}

Here we take advantage of the finite view constructor std::views::iota(1,10) to establish the output size (line 7), which allows us to use the infinite view std::views::iota(5) for the second parameter. Functionally, we could swap even the second view for a finite one. However, this would impose an additional (and unnecessary) boundary check.
