\section{Generators}

The C++ standard offers three types of generators: fill with copies of a value, fill with results of invoking a generator functor and fill with sequentially increasing values.

\subsection{\texorpdfstring{\cpp{std::fill}, \cpp{std::generate}}{\texttt{std::fill}, \texttt{std::generate}}}

The \cpp{std::fill} algorithm fills a range by consecutively assigning the given value to each element.
The \cpp{std::generate} algorithm fills a range by consecutively assigning the result of the provided generator.

\cppversions{\texttt{fill}, \texttt{generate}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{\texttt{forward\_range}}{N/A}{\texttt{generator}}

The generator provided to \cpp{std::generate} can be a non-regular function since \cpp{std::generate} guarantees strict left-to-right evaluation.

\begin{box-note}
\footnotesize Example of using std::fill and std::generate.
\tcblower
\cppfile{code_examples/algorithms/generate_code.h}
\end{box-note}


\subsection{\texorpdfstring{\cpp{std::fill_n}, \cpp{std::generate_n}}{\texttt{std::fill\_n}, \texttt{std::generate\_n}}}


\cppversions{\texttt{fill\_n, generate\_n}}{\CC98}{\CC20}{\CC17}{\CC20}

\subsection{iota}

Iota is an outlier when it comes to C++20 std::ranges support. C++20 introduced the lazy view version std::views::iota, and we will only get the eager range version of the algorithm in C++23.

\cppversions{\texttt{iota}}{\CC11}{\CC20}{N/A}{\CC23}

\constraints{\texttt{forward\_range}}{}{}{}

The std::iota algorithm will generate elements by consecutively applying the prefix increment operator, starting with the initial value.

\begin{box-note}
\begin{cppcode}
std::vector<int> data(11, 0);

std::iota(data.begin(), data.end(), -5); 
// data == { -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 }

std::vector<int> out;
std::ranges::transform(std::views::iota(1, 10), std::views::iota(5), 
                       std::back_inserter(out), std::plus<>{});
// out == { 6, 8, 10, 12, 14, 16, 18, 20, 22 }
\end{cppcode}
\end{box-note}

Here we take advantage of the finite view constructor std::views::iota(1,10) to establish the output size (line 7), which allows us to use the infinite view std::views::iota(5) for the second parameter. Functionally, we could swap even the second view for a finite one. However, this would impose an additional (and unnecessary) boundary check.

\subsection{fill, fill\_n, generate, generate\_n}



The std::fill algorithm fills the designated range with the provided value, and std::generate fills the designated range with values resulting from successive invocations of the provided invocable.

\begin{box-note}
\begin{cppcode}
std::vector<int> data(5, 0);
std::fill(data.begin(), data.end(), 11);
// data == (11, 11, 11, 11, 11)

std::ranges::generate(data, []() { return 5; });
// data == (5, 5, 5, 5, 5)

// iota-like
std::ranges::generate(data, [i = 0]() mutable { return i++; });
// data == (0, 1, 2, 3, 4)
\end{cppcode}
\end{box-note}

The iota-like behaviour (line 9) is possible because the standard guarantees successive (left-to-right) invocations of the provided invocable.

When working with ranges that do not support random access, it might be slow or impossible to provide the end of the range iterator. The standard offers variants of fill and generate where the range is specified using a begin iterator and the number of elements to cover this case.



\constraints{\texttt{output\_iterator}}{\texttt{forward\_iterator}}{}{}

Other than the change in how a range is specified, these variants have identical behaviour to the baseline algorithms.

\begin{box-note}
\begin{cppcode}
std::vector<int> data;
std::fill_n(std::back_inserter(data), 5, 11);
// data == (11, 11, 11, 11, 11)

data.clear();
std::ranges::generate_n(std::back_inserter(data), 5, []() { return 5; });
// data == (5, 5, 5, 5, 5)
\end{cppcode}
\end{box-note}
