\section{Swaps}

Before discussing swaps, we need to make a short detour and discuss argument-dependent lookup, an essential aspect of the pre-C++20 version of the std::swap algorithm.

Argument-dependent lookup is relied upon heavily in C++, notably when overloading operators.

\begin{box-note}
\footnotesize Example of argument-dependent lookup for \cpp{operator<<} implemented as a function.
\tcblower
\cppfile{code_examples/theory/adl_code.h}
\end{box-note}

The situation changes slightly when the function is implemented as a friend function. Such a function is a member of the surrounding namespace. However, it is not visible outside of ADL.

\begin{box-note}
\footnotesize Example of argument-dependent lookup for \cpp{operator<<} implemented as a friend function.
\tcblower
\cppfile{code_examples/theory/adl_friend_code.h}
\end{box-note}

The benefit of relying on ADL is that there is no complexity on the caller's site. An unqualified call will invoke the correct overload. Except, this wouldn't be C++ if there weren't an exception to this rule.

If on top of having the ability to specialize, we also want default behaviour as a fallback, the caller now needs to make sure to pull in the default overload to the local scope.

\begin{box-note}
\footnotesize Example of argument-dependent lookup with a default templated version of the function.
\tcblower
\cppfile{code_examples/theory/adl_default_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::swap}}{\texttt{std::swap}}}

The non-range version of \cpp{std::swap} will swap the values of the two parameters using a three-step move-swap. Users can provide a more optimized implementation as friend functions on their type.

\cppversions{\texttt{swap}}{\CC98}{\CC20}{N/A}{\CC20}

Correctly calling swap (as mentioned at the beginning of this section) requires pulling the default std::swap version to the local scope.

\begin{box-note}
\footnotesize Example of correctly calling \cpp{std::swap}.
\tcblower
\cppfile{code_examples/algorithms/swap_calling_code.h}
\end{box-note}
\newpage

The C++20 rangified version of swap removes this complexity, and it will:

\begin{itemize}
    \item call the user-provided (found by ADL) overload of swap
    \item if that doesn't exist and the parameters are arrays of the same span, \cpp{std::ranges::swap} will behave as \cpp{std::ranges::swap_ranges}
    \item if the parameters are also not arrays, it will default to a move-swap
\end{itemize}

\begin{box-note}
\footnotesize Example of specializing and calling \cpp{std::ranges::swap}.
\tcblower
\cppfile{code_examples/algorithms/swap_ranges_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::iter_swap}}{\texttt{std::iter\_swap}}}

The \cpp{std::iter_swap} is an indirect swap, swapping values behind two forward iterators. The range version extends the functionality to other dereferenceable objects.

\cppversions{\texttt{iter\_swap}}{\CC98}{\CC20}{N/A}{\CC20}

\constraints{(\cpp{forward_iterator}, \cpp{forward_iterator}) (non-range)}{}{}{}



Let’s finally talk about the other two variants, iter\_swap and swap\_ranges.



Iter swap could also be called indirect swap, swapping the underlying values behind iterators or other indirect types. It is mainly helpful for implementing custom algorithms since those operate on iterators.

Here is an example of a partition algorithm implementation using iter\_swap (line 12):

\begin{box-note}
\begin{cppcode}
template <typename It, typename Cond>
    requires std::forward_iterator<It> 
        && std::indirectly_swappable<It,It> 
        && std::predicate<Cond>
auto partition(It first, It last, Cond cond) {
    while (first != last && cond(first)) ++first;
    if (first == last) return last;

    for (auto it = std::next(first); it != last; it++) {
        if (!cond(it)) continue;

        std::iter_swap(it, first);
        ++first;
    }
    return first;
}
\end{cppcode}
\end{box-note}

\subsection{swap\_ranges}

Swap ranges is a piecewise swap of two non-overlapping ranges (potentially from the same container). A begin iterator specifies the second range, and it is the caller’s responsibility to ensure that the target range has enough capacity.

\cppversions{\texttt{swap\_ranges}}{\CC98}{\CC20}{\CC17}{\CC20}

\begin{box-note}
\begin{cppcode}
std::vector<int> data{ 1, 2, 3, 4, 5, 6, 7, 8, 9};
std::swap_ranges(data.begin(), data.begin()+3, data.rbegin());
// 9, 8, 7, 4, 5, 6, 3, 2, 1
\end{cppcode}
\end{box-note}

Here we swap the first three elements of the array with the last three elements of the array. The order of elements is reversed because we use rbegin (begin iterator for reverse iteration).