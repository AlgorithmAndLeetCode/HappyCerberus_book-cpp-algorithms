\section{Transformation algorithms}

In this section, we will discuss algorithms that transform ranges by changing the values of elements and removing and re-ordering elements.

\subsection{\texorpdfstring{\cpp{std::transform}}{\texttt{std::transform}}}

The most straightforward transformation possible is to apply a transformation function to each element. The \cpp{std::transform} algorithm provides this functionality in unary and binary variants (input from one or two ranges).

\cppversions{\texttt{transform}}{\CC98}{\CC20}{\CC17}{\CC20}

% Mention lazy version

\constraints{\texttt{input\_range -> output\_iterator}\newline\texttt{(input\_range, input\_iterator) -> output\_iterator}}{\texttt{forward\_range -> forward\_iterator}\newline\texttt{(forward\_range, forward\_iterator) -> forward\_iterator}}{N/A}{\texttt{unary\_functor}\newline\texttt{binary\_functor}}

\begin{box-note}
\footnotesize Example of unary and binary version of \cpp{std::transform}. Note that the output iterator can be one of the input ranges' begin iterator (line 4 and 12).
\tcblower
\cppfile{code_examples/algorithms/transform_code.h}
\end{box-note}

Note that \cpp{std::transform} does not guarantee strict left-to-right evaluation. If that is required, use \cpp{std::for_each} instead.

\subsection{\texorpdfstring{\cpp{std::adjacent_difference}}{\texttt{std::adjacent\_difference}}}

The \cpp{std::adjacent_difference} is a numerical algorithm, which might make it seem out of place in this section; however, it is essentially a binary transformation algorithm that operates on adjacent elements of the single source range.

Unlike \cpp{std::transform}, \cpp{std::adjacent_difference} guarantees left-to-right application. Furthermore, because it operates on input ranges, the algorithm internally stores a copy of the last read value for use as the left operand in the next step.

\cppversions{\texttt{adjacent\_difference}}{\CC98}{\CC20}{\CC17}{N/A}
\constraints{\texttt{input\_range -> output\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{\texttt{operator -}}{\texttt{binary\_functor}}

\begin{box-note}
\footnotesize Example of the default version of \cpp{std::adjacent_difference}, which will calculate the difference of adjacent elements, with the first element copied.
\tcblower
\cppfile{code_examples/algorithms/adjacent_difference_code.h}
\end{box-note}

\begin{box-note}
\footnotesize Example of more inventive use of \cpp{std::adjacent_difference} to generate the Fibonacci sequence.
\tcblower
\cppfile{code_examples/algorithms/adjacent_difference_extra_code.h}
\end{box-note}

Note that the \cpp{std::next(data.begin())} for the output range is critical here. The \cpp{std::adjacent_difference} algorithm will read each element only once and remembers the previously read value for the left argument. The \cpp{std::next} ensures that we generate one element ahead of either argument.

\subsection{\texorpdfstring{\cpp{std::remove}, \cpp{std::remove_if}}{\texttt{std::remove}, \texttt{std::remove\_if}}}

The \cpp{std::remove} and \cpp{std::remove_if} algorithms "remove" elements that match the given value or for which the given predicate evaluates to true.

Because the algorithms cannot resize the underlying range, the removal is achieved by moving the other elements in the range. The algorithms then return an iterator beyond the last not removed element, i.e. the new end iterator.

\cppversions{\texttt{remove, remove\_if}}{\CC98}{\CC20}{\CC17}{\CC20}
\constraints{\texttt{forward\_range}}{\texttt{forward\_range}}{N/A}{\texttt{unary\_predicate}}

\begin{box-note}
\footnotesize Example of using \cpp{std::remove} and \cpp{std::remove_if}.
\tcblower
\cppfile{code_examples/algorithms/remove_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::remove}, \cpp{std::remove_if}}{\texttt{std::remove}, \texttt{std::remove\_if}}}

The \cpp{std::replace} and \cpp{std::replace_if} algorithms replace elements that match the given value or for which the given predicate evaluates to true.

\cppversions{\texttt{replace, replace\_if}}{\CC98}{\CC20}{\CC17}{\CC20}
\constraints{\texttt{forward\_range}}{\texttt{forward\_range}}{N/A}{\texttt{unary\_predicate}}

\begin{box-note}
\footnotesize Example of using \cpp{std::replace} and \cpp{std::replace_if}.
\tcblower
\cppfile{code_examples/algorithms/replace_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::reverse}}{\texttt{std::reverse}}}

The \cpp{std::reverse} algorithm will reverse the order of elements in the range by applying \cpp{std::swap} to pairs of elements.

\cppversions{\texttt{reverse}}{\CC98}{\CC20}{\CC17}{\CC20}
\constraints{\texttt{bidirectional\_range}}{\texttt{bidirectional\_range}}{}{}

Note that using \cpp{std::reverse} is only a reasonable solution if the range must be mutated because bidirectional ranges already support reverse iteration.

\begin{box-note}
\footnotesize Example of using \cpp{std::reverse} and reverse iteration, provided by bidirectional ranges.
\tcblower
\cppfile{code_examples/algorithms/reverse_code.h}
\end{box-note}

C-style arrays and C-style strings can be adapted using \cpp{std::span} and \cpp{std::string_view} to allow reverse iteration.

\begin{box-note}
\footnotesize Example of using \cpp{std::span} and \cpp{std::string_view} to addapt C-style constructs for reverse iteration.
\tcblower
\cppfile{code_examples/extras/span_stringview_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::rotate}}{\texttt{std::rotate}}}
\subsection{\texorpdfstring{\cpp{std::shuffle}}{\texttt{std::shuffle}}}

\subsection{reverse, rotate, shuffle}



The rotate algorithm does precisely that, and it rotates the elements in the range such that the designated element is now the first element of the range.

\cppversions{\texttt{rotate}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(forward\_range, forward\_iterator)}}{}{}{}

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7};
std::rotate(data.begin(), data.begin()+3, data.end());
// data=4, 5, 6, 7, 1, 2, 3
\end{cppcode}
\end{box-note}

The shuffle algorithm is a successor of the now-defunct random\_shuffle algorithm (deprecated in C++14, removed in C++17) and relies on new random facilities added in C++11.

\cppversions{\texttt{shuffle}}{\CC11}{N/A}{N/A}{\CC20}

\constraints{\texttt{random\_access\_range}}{}{}{}

The random facilities are out of scope for this article. However, shuffle will work with any uniform random bit generator.

\begin{box-note}
\begin{cppcode}
struct Card {
    unsigned index;
    
    friend std::ostream& operator << (std::ostream& s, const Card& card) {
        static constexpr std::array<const char*, 13> ranks = {"Ace", "Two", "Three", 
          "Four", "Five", "Six", "Seven", "Eight", 
          "Nine", "Ten", "Jack", "Queen", "King"};
        static constexpr std::array<const char*, 4> suits = {"Hearts", "Diamonds", 
                                                             "Clubs", "Spades"};

        if (card.index >= 52)
            throw std::domain_error("Card index has to be in the range 0..51");

        s << ranks[card.index%13] << " of " << suits[card.index/13];

        return s;
    }
};

std::vector<Card> deck(52, Card{});
std::ranges::generate(deck, [i = 0u]() mutable { return Card{i++}; });
// deck = {Ace of Hearts, Two of Hearts, Three of Hearts, Four of Hearts...}

std::random_device rd;
std::mt19937 gen{rd()};

std::ranges::shuffle(deck, gen);
// deck = { random order }
\end{cppcode}
\end{box-note}

We use the std::generate algorithm, which we will discuss in an upcoming article, to generate the 52 unique cards (line 21). After generating, the cards will be in sorted order.

We then use the Mersenne Twister Engine uniform bit generator (in its 32bit pre-defined alias), which we pass to the shuffle algorithm resulting in a randomly shuffled range.

The output stream operator overload on lines 4–17 provides the translation from index to a text representation, e.g. “Jack of Clubs”.

\subsection{next\_permutation, prev\_permutation, is\_permutation}

Permutation algorithms will generate either the next or previous permutation in lexicographical order.

\cppversions{\texttt{next\_permutation, prev\_permutation}}{\CC98}{\CC20}{N/A}{\CC20}

\constraints{\texttt{bidirectional\_range}}{}{\texttt{operator <}}{\texttt{strict\_weak\_ordering}}

Strictly speaking, calling next\_permutation will adjust the order of elements such that it is the next higher value as per std::lexicographical\_compare (using the same functor). If there is no such range, next\_permutation will cycle back to the lowest value and return false.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3};
do {
    // iterate over:
    // 1, 2, 3
    // 1, 3, 2
    // 2, 1, 3
    // 2, 3, 1
    // 3, 1, 2
    // 3, 2, 1
} while (std::next_permutation(data.begin(), data.end()));
// data = {1, 2, 3}
\end{cppcode}
\end{box-note}

When used with a range of booleans, next\_permutation can serve to iterate over all sets of a particular size.

\begin{box-note}
\begin{cppcode}
std::vector<std::string> data{"apple", "avocado", "banana", 
  "cherry", "lemon", "mango", 
  "orange", "plums", "watermelon"};

std::vector<char> pick(data.size(), false);
std::fill_n(pick.begin(), 3, true);

do {
    for (size_t i = 0; i < pick.size(); ++i) {
        if (pick[i])
            std::cout << data[i] << ", ";
    }
    std::cout << "\n";
} while (std::prev_permutation(pick.begin(), pick.end(), std::less<bool>()));
\end{cppcode}
\end{box-note}

We start with a range filled with false values, setting the first three elements to true (line 6). We then print out the elements corresponding to the TRUE values (line 10). Finally, prev\_permutation will return false once we have cycled back to the initial range with the first three elements set to true (line 14).

Lastly, to check whether one range is a permutation of another, we can use the is\_permutation algorithm.

\cppversions{\texttt{is\_permutation}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(forward\_range, forward\_range)}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

The utility of is\_permutation mainly pops up in testing, where we often need to test whether two ranges are piecewise equal but not necessarily in the same order.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 8, 1, 7, 3, 4, 6, 2, 5};
for (size_t i = 0; i < data.size()-1; ++i)
    for (size_t j = i+1; j < data.size(); ++j)
        if (data[i] > data[j])
            std::swap(data[i], data[j]);

assert(std::ranges::is_sorted(data));
assert(std::ranges::is_permutation(data, 
                                   std::vector<int>{1, 2, 3, 4, 5, 6, 7, 8}));
\end{cppcode}
\end{box-note}