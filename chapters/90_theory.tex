\chapter{Bits of C++ theory}

This chapter will dive deep into the various topics referenced throughout the book. While this chapter serves as a reference, the topics are still presented in a heavily simplified, example-heavy format. For a proper reference, please refer to the C++ standard.

\section{Argument-dependent lookup (ADL)}

When calling a method without qualification (i.e. not specifying the namespace), the compiler needs to determine the set of candidate functions. As a first step, the compiler will do an unqualified name lookup, which starts at the local scope and examines the parent scopes until it finds the first instance of the name (at which point it stops).

\begin{box-note}
\footnotesize Example of unqualified lookup. Both calls to \cpp{some_call} will resolve to \cpp{::A::B::some_call} since this is the first instance discovered by the compiler.
\tcblower
\cppfile{code_examples/theory/adl_unqalified_code.h}
\end{box-note}

Due to the simplicity of unqualified lookup, we need an additional mechanism to discover overloads. Notably, it is a requirement for operator overloading since operator calls are unqualified. This is where argument-dependent lookup comes in.

\begin{box-note}
\footnotesize Without ADL, any call to a custom operator overload would have to be fully qualified, requiring the function call syntax.
\tcblower
\cppfile{code_examples/theory/adl_code.h}
\end{box-note}

While the full rules for ADL are quite complex, the heavily simplified version is that the compiler will also consider the innermost namespace of all the arguments when determining the viable function overloads.

\begin{box-note}
\footnotesize 
\tcblower
\cppfile{code_examples/theory/adl_simple_code.h}
\end{box-note}

Arguably the true power of ADL lies in the interactions with other language features, so let's look at how ADL interacts with friend functions and function objects.

\subsection{Friend functions vs ADL}

Friend functions (when defined inline) do not participate in the normal lookup (they are part of the surrounding namespace but are not visible). However, they are still visible to ADL, which permits a common implementation pattern for a default implementation with a customization point through ADL.

\begin{box-note}
\footnotesize Example demonstrating a default implementation with a customization point through ADL. The default implementation needs to be discovered during the unqualified lookup; therefore, if any custom implementation is visible in the surrounding namespaces, it will block this discovery.
\tcblower
\cppfile{code_examples/theory/adl_default_code.h}
\end{box-note}

\subsection{Function objects vs ADL}

