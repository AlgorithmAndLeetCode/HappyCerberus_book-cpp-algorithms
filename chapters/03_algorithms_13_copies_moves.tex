\section{Copy and move}

The standard offers a wide range of copy algorithms in roughly three categories: simple copies and moves, selective copies and copies with reordering.

\subsection{\texorpdfstring{\cpp{std::copy}, \cpp{std::move}}{\texttt{std::copy}, \texttt{std::move}}}

The \cpp{std::copy} and \cpp{std::move} algorithms provide a forward copy and move. The direction is important for overlapping ranges, so we do not overwrite the yet-to-be copied elements.

For the forward direction, the output iterator is not permitted to be within \texttt{[first, last)} (of the input range). Consequently, only the tail of the output range can overlap with the input range.

\cppversions{\texttt{copy}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{move}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range -> output\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{}{}

\begin{box-note}
\footnotesize Example of a non-overlapping and permitted overlapping case of \cpp{std::copy}.
\tcblower
\cppfile{code_examples/algorithms/copy_code.h}
\end{box-note}

Move operates identically, except it casts each element to an rvalue before the assignment, turning copies into moves.

\begin{box-note}
\footnotesize Example of using \cpp{std::move}.
\tcblower
\cppfile{code_examples/algorithms/move_code.h}
\end{box-note}

Significantly, whether std::move will move depends on the underlying element type. If the underlying type is copy-only, std::move will behave identically to std::copy.

\begin{box-note}
\footnotesize Example of using \cpp{std::move} with a copy-only type.
\tcblower
\cppfile{code_examples/algorithms/move_nomove_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::copy_backward}, \cpp{std::move_backward}}{\texttt{std::copy\_backward}, \texttt{std::move\_backward}}}

The \cpp{std::copy_backward} and \cpp{std::move_backward} are variants that copy in the opposite direction, starting at the back of the range. Because of this, the head of the output range can now overlap with the input range.

\cppversions{\texttt{copy\_backward}}{\CC98}{\CC20}{N/A}{\CC20}
\cppversions{\texttt{move\_backward}}{\CC11}{\CC20}{N/A}{\CC20}

\constraints{\texttt{bidirectional\_range -> bidirectional\_iterator}}{}{}{}

The output iterator cannot be within \cpp{(first, last]} and will be treated as the end iterator for the destination range, meaning that the algorithm will write the first value to \cpp{std::prev(end)}.

\begin{box-note}
\footnotesize Example of a non-overlapping and permitted overlapping case of \cpp{std::copy_backward}.
\tcblower
\cppfile{code_examples/algorithms/copy_backward_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::copy_n}}{\texttt{std::copy\_n}}}

The \cpp{std::copy_n} algorithm is the counted variant of \cpp{std::copy} that accepts an input range specified using an iterator and the number of elements.

\cppversions{\texttt{copy\_n}}{\CC11}{\CC20}{\CC17}{\CC20}
\constraints{\texttt{input\_iterator -> output\_iterator}}{\texttt{forward\_iterator -> forward\_iterator}}{}{}

The algorithm cannot check whether the requested count is valid and does not go out of bounds, so this burden is on the caller.

\begin{box-note}
\footnotesize Example of using \cpp{std::copy_n}.
\tcblower
\cppfile{code_examples/algorithms/copy_n_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::copy_if}, \cpp{std::remove_copy}, \cpp{std::remove_copy_if}}{\texttt{std::copy\_if}, \texttt{std::remove\_copy}, \texttt{std::remove\_copy\_if}}}

The \cpp{std::copy_if}, \cpp{std::remove_copy} and \cpp{std::remove_copy_if} are selective copy algorithms.

\cppversions{\texttt{copy\_if}}{\CC11}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{remove\_copy}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{remove\_copy\_if}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range -> output\_range}}{\texttt{forward\_range -> forward\_iterator}}{N/A}{\texttt{unary\_predicate}}

The \cpp{std::remove_copy} algorithm will copy elements that do not match the provided value. The \cpp{std::copy_if} and \cpp{std::remove_copy_if} algorithms will copy elements based on a predicate, with \cpp{std::copy_if} copying elements for which the predicate returns true and \cpp{std::remove_copy_if} copying elements for which the predicate returns false.

\begin{box-note}
\footnotesize Example demonstrating differences between \cpp{std::copy_if}, \cpp{std::remove_copy} and \cpp{std::remove_copy_if}.
\tcblower
\cppfile{code_examples/algorithms/copy_if_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::sample}}{\texttt{std::sample}}}

The \cpp{std::sample} algorithm is a random selective copy algorithm. The algorithm will copy a random selection of N elements from the source range to the destination range utilising the provided random number generator.

\cppversions{\texttt{sample}}{\CC17}{N/A}{N/A}{\CC20}
\constraints{\texttt{forward\_range -> output\_iterator}\newline \texttt{input\_range -> random\_access\_iterator}}{}{}{}

The two domains of this algorithm are due to the stable nature of the sampling, maintaining the order of elements from the source range. This feature requires either the input range to be at least a forward range or the destination range needs to be a random-access range.

\begin{box-note}
\footnotesize Example of using \cpp{std::sample}.
\tcblower
\cppfile{code_examples/algorithms/sample_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::replace_copy}, \cpp{std::replace_copy_if}}{\texttt{std::replace\_copy}, \texttt{std::replace\_copy\_if}}}

The \cpp{std::replace_copy} and \cpp{std::replace_copy_if} algorithms operate like \cpp{std::copy}; however, they will copy a provided value instead of specific elements.

For \cpp{std::replace_copy}, the algorithm will replace elements matching a value for \cpp{std::replace_copy_if} the algorithm will replace elements for which the predicate evaluates to true.

\cppversions{\texttt{replace\_copy}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{replace\_copy\_if}}{\CC98}{\CC20}{\CC17}{\CC20}
\constraints{\texttt{input\_range -> output\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{N/A}{\texttt{unary\_predicate}}

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector<int> out, odd;

std::ranges::replace_copy(data, std::back_inserter(out), 5, 10);
// out == { 1, 2, 3, 4, 10, 6, 7, 8, 9 }

auto even = [](int v) { return v % 2 == 0; };
std::ranges::replace_copy_if(data, std::back_inserter(odd), even, -1);
// odd == { 1, -1, 3, -1, 5, -1, 7, -1, 9 }
\end{cppcode}
\end{box-note}

\subsection{reverse\_copy, rotate\_copy}

The last two algorithms from the copiers category change the order of copied elements.

\cppversions{\texttt{reverse\_copy}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{bidirectional\_range -> output\_iterator}}{\texttt{bidirectional\_range -> forward\_iterator}}{}{}

Not to be confused with copy\_backwards, which maintains the original order of elements, reverse\_copy will reverse the order of elements copied.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector<int> out;

std::ranges::reverse_copy(data, std::back_inserter(out));
// out == { 9, 8, 7, 6, 5, 4, 3, 2, 1 }
\end{cppcode}
\end{box-note}

\cppversions{\texttt{rotate\_copy}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(forward\_range, forward\_iterator) -> output\_iterator}}{\texttt{(forward\_range, forward\_iterator) -> forward\_iterator}}{}{}

Following the logic of the rotate algorithm, rotate\_copy will first copy the elements starting from the designated middle element and then follow with the remaining elements from the beginning of the range.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector<int> out;

std::ranges::rotate_copy(data, data.begin()+4, std::back_inserter(out));
// out == { 5, 6, 7, 8, 9, 1, 2, 3, 4 }
\end{cppcode}
\end{box-note}
