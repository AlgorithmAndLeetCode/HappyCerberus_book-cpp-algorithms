\section{Min-Max algorithms}

This group contains straightforward algorithms that operate with minimums and maximums. However, two theoretical topics are relevant here, and we need to talk about them first: \cpp{std::initializer_list} and \cpp{const_cast}.

For functions that accept an \cpp{std::initializer_list}, it is worth keeping in mind that \cpp{std::initializer_list} is constructed by copy; its internal array of elements is copy constructed from the listed elements. Therefore we need to be careful when using \cpp{std::initializer_list} outside of compile-time contexts.

\begin{box-note}
\footnotesize Example demonstrating case when utilizing \cpp{std::initializer_list} leads to excessive copies.
\tcblower
\cppfile{code_examples/theory/initializer_list_code.h}
\end{box-note}

In this example, using \cpp{std::initializer_list} leads to six copies (which we count using the static data member \cpp{X::copy_cnt}). Five copies result from passing in the variables \texttt{a} to \texttt{e} into the \cpp{std::initializer_list}, and one is the result of the return from \cpp{std::max}.

In rare cases, we can force constness on a mutable entity. If the constness is undesirable, using \cpp{const_cast} to cast away the const is an option.

\begin{box-note}
\footnotesize Example demonstrating the valid and invalid uses for \cpp{const_cast}.
\tcblower
\cppfile{code_examples/theory/const_cast_code.h}
\end{box-note}

Please remember that when using casts like \cpp{const_cast}, you effectively override the compiler's judgment. Therefore it is entirely up to you to ensure that the given cast is valid.

\subsection{\texorpdfstring{\cpp{std::min}, \cpp{std::max}, \cpp{std::minmax}}{\texttt{std::min}, \texttt{std::max}, \texttt{std::minmax}}}

The basic versions of \cpp{std::min}, \cpp{std::max} and \cpp{std::minmax} operate on two elements, accepting their arguments by const-reference and returning by const-reference. Unfortunately, as mentioned earlier, this creates a constness problem, and we also must be careful to capture the result by value when passing in temporary objects.

\cppversions{\texttt{min, max}}{\CC98}{\CC14}{N/A}{\CC20}
\cppversions{\texttt{minmax}}{\CC11}{\CC14}{N/A}{\CC20}

\begin{box-note}
\footnotesize Example demonstrating use of \cpp{std::min} and \cpp{std::max}.
\tcblower
\cppfile{code_examples/algorithms/min_max_code.h}
\end{box-note}

Capturing the result by value gets a bit more complicated with \cpp{std::minmax}, which returns a \cpp{std::pair} of const references. To avoid dangling references to expired prvalues we must explicitly name the result type. Unfortunately, there is no way to work around this problem when using auto or structured binding.

\begin{box-note}
\footnotesize Example demonstrating use of \cpp{std::minmax}.
\tcblower
\cppfile{code_examples/algorithms/minmax_code.h}
\end{box-note}


\constraints{\texttt{initializer\_list} since \CC14}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}
\constraints{\texttt{input\_range} \CC20 range version only}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

Until C++14, the only variants available operated on two elements only, returning a const-reference. Then, the C++14 standard introduced a variant that operates on an initializer list, which returns by value. Finally, C++20 introduced a range variant that operates on input ranges and returns by value.

\begin{box-note}
\begin{cppcode}
auto i = std::min(1, 2);
// i == 1

auto j = std::max(1, 2);
// j == 2

auto v = std::minmax({5, 3, -2, 0});
// v.first == -2, v.second == 5

std::list<int> data = {5, 3, -2, 0};
auto k = std::ranges::min(data);
// k == -2
\end{cppcode}
\end{box-note}

\subsection{min\_element, max\_element, minmax\_element}

The element versions of min-max algorithms operate on ranges and, instead of returning by const-reference or value, return an iterator to the minimum or maximum elements.

\cppversions{\texttt{min\_element, max\_element}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{minmax\_element}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

All variants require forward\_range as they return iterators to the min-max elements instead of a value.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 5, 3, -2 , 0};
auto i = std::min_element(data.begin(), data.end());
// *i == -2 (i.e. data[2])
auto j = std::max_element(data.begin(), data.end());
// *j == 5 (i.e. data[0])

auto k = std::minmax_element(data.begin(), data.end());
// *k.first == -2, *k.second == 5
\end{cppcode}
\end{box-note}

\subsection{clamp}

The std::clamp algorithm is one of the few algorithms that do not operate on ranges.

\cppversions{\texttt{clamp}}{\CC17}{\CC17}{N/A}{\CC20}

The clamp algorithm will clamp the given value in between the provided minimum and maximum:

\begin{itemize}
    \item if $value < minimum$, std::clamp returns the minimum
    \item if $maximum < value$, std::clamp returns the maximum
    \item otherwise, std::clamp returns the value
\end{itemize}

\begin{box-note}
\begin{cppcode}
int a = std::ranges::clamp(10, 0, 20);
// a == 10 (0 < 10 && 10 < 20)

int b = std::clamp(-20, 0, 20);
// b == 0 (-20 < 0)

int c = std::clamp(30, 0, 20);
// c == 20 ( 30 > 20 )
\end{cppcode}
\end{box-note}