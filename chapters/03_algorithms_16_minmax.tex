\section{Min-Max algorithms}

This group contains straightforward algorithms that operate with minimums and maximums. However, we should first talk about \cpp{std::initializer_list} and \cpp{const_cast}.

For functions that accept an \cpp{std::initializer_list}, it is worth keeping in mind that \cpp{std::initializer_list} is constructed by copy; its internal array of elements is copy constructed from the listed elements. Therefore we need to be careful when using \cpp{std::initializer_list} outside of compile-time contexts.

In rare cases, we can force constness on a mutable entity. If the constness is undesirable, using \cpp{const_cast} to cast away the const is an option.

\begin{box-note}
\footnotesize Example demonstrating the valid and invalid uses for \cpp{const_cast}.
\tcblower
\cppfile{code_examples/theory/const_cast_code.h}
\end{box-note}

Please remember that when using casts like \cpp{const_cast}, you effectively override the compiler's judgment. Therefore it is entirely up to you to ensure that the given cast is valid.

\subsection{min, max, minmax}

The first group of min-max algorithms also do not operate on ranges (except a C++20 range variant).

\cppversions{\texttt{min, max}}{\CC98}{\CC14}{N/A}{\CC20}
\cppversions{\texttt{minmax}}{\CC11}{\CC14}{N/A}{\CC20}

\constraints{\texttt{initializer\_list} since \CC14}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}
\constraints{\texttt{input\_range} \CC20 range version only}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

Until C++14, the only variants available operated on two elements only, returning a const-reference. Then, the C++14 standard introduced a variant that operates on an initializer list, which returns by value. Finally, C++20 introduced a range variant that operates on input ranges and returns by value.

\begin{box-note}
\begin{cppcode}
auto i = std::min(1, 2);
// i == 1

auto j = std::max(1, 2);
// j == 2

auto v = std::minmax({5, 3, -2, 0});
// v.first == -2, v.second == 5

std::list<int> data = {5, 3, -2, 0};
auto k = std::ranges::min(data);
// k == -2
\end{cppcode}
\end{box-note}

\subsection{min\_element, max\_element, minmax\_element}

The element versions of min-max algorithms operate on ranges and, instead of returning by const-reference or value, return an iterator to the minimum or maximum elements.

\cppversions{\texttt{min\_element, max\_element}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{minmax\_element}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

All variants require forward\_range as they return iterators to the min-max elements instead of a value.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 5, 3, -2 , 0};
auto i = std::min_element(data.begin(), data.end());
// *i == -2 (i.e. data[2])
auto j = std::max_element(data.begin(), data.end());
// *j == 5 (i.e. data[0])

auto k = std::minmax_element(data.begin(), data.end());
// *k.first == -2, *k.second == 5
\end{cppcode}
\end{box-note}

\subsection{clamp}

The std::clamp algorithm is one of the few algorithms that do not operate on ranges.

\cppversions{\texttt{clamp}}{\CC17}{\CC17}{N/A}{\CC20}

The clamp algorithm will clamp the given value in between the provided minimum and maximum:

\begin{itemize}
    \item if $value < minimum$, std::clamp returns the minimum
    \item if $maximum < value$, std::clamp returns the maximum
    \item otherwise, std::clamp returns the value
\end{itemize}

\begin{box-note}
\begin{cppcode}
int a = std::ranges::clamp(10, 0, 20);
// a == 10 (0 < 10 && 10 < 20)

int b = std::clamp(-20, 0, 20);
// b == 0 (-20 < 0)

int c = std::clamp(30, 0, 20);
// c == 20 ( 30 > 20 )
\end{cppcode}
\end{box-note}