\section{Uninitialized memory algorithms}

The uninitialized memory algorithms are a group of relatively low-level algorithms designed to help when implementing manual memory management. These algorithms provide the functionality to transactionally construct, copy, move and destroy sequences of elements on top of raw memory.

% TODO: note and link the advanced chapter on manual memory management.

The counted variants of the algorithms are not listed in this section\footnote{The names of these algorithms are particularly long and obnoxious.}. However, note that all algorithms in this section that operate on ranges have a counted variant, where the range is specified using an iterator and number of elements. These variants are used in some of the examples to demonstrate.

\subsection{\texorpdfstring{\cpp{std::construct_at}, \cpp{std::destroy_at}}{\texttt{std::construct\_at}, \texttt{std::destroy\_at}}}

The \cpp{std::construct_at} and \cpp{std::destroy_at} algorithms will construct/destroy a single element at a given address. If additional arguments are specified, \cpp{std::construct_at} will forward these to the objects’ constructor.

\cppversions{\texttt{construct\_at}}{\CC20}{\CC20}{N/A}{\CC20}
\cppversions{\texttt{destroy\_at}}{\CC17}{\CC20}{N/A}{\CC20}

\begin{box-note}
\footnotesize Example of using \cpp{std::create_at} to create a \cpp{std::string} object using the arguments eight and ‘X’, which results in a string filled with eight copies of the X character.
\tcblower
\cppfile{code_examples/algorithms/create_at_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::uninitialized_default_construct},\newline\cpp{std::uninitialized_value_construct},\newline\cpp{std::uninitialized_fill}, \newline\cpp{std::destroy}}{\texttt{std::uninitialized\_default\_construct},\newline\texttt{std::uninitialized_value_construct},\newline\texttt{std::uninitialized_fill}, \newline\texttt{std::destroy}}}

The three uninitialized algorithms cover the default initialization, value initialization and copy initialization of elements. The \cpp{std::destroy} algorithm provides the destruction of elements without deallocating the underlying memory.

\cppversions{\texttt{un\dots default\_construct}}{\CC17}{N/A}{\CC17}{\CC20}
\cppversions{\texttt{un\dots value\_construct}}{\CC17}{N/A}{\CC17}{\CC20}
\cppversions{\texttt{uninitialized\_fill}}{\CC98}{N/A}{\CC17}{\CC20}
\cppversions{\texttt{destroy}}{\CC17}{N/A}{\CC17}{\CC20}

\constraints{\texttt{forward\_range\newline forward\_iterator (counted)}}{}{}{} % Cleanup the counted variant situation

\begin{box-note}
\begin{cppcode}
alignas(alignof(std::string)) char buffer[sizeof(std::string)*10];
auto *begin = reinterpret_cast<std::string*>(buffer);
auto *it = begin;

std::uninitialized_default_construct_n(it, 3);
it += 3;
std::uninitialized_fill_n(it, 2, "Hello World!");
it += 2;
std::uninitialized_value_construct_n(it, 3);
it += 3;
std::uninitialized_fill_n(it, 2, "Bye World!");

// {"", "", "", "Hello World!", "Hello World!", "", "", "", "Bye World!", "Bye World!"}

std::destroy_n(begin, 10);
\end{cppcode}
\end{box-note}

For std::string, there is no difference between default and value initialization. In both cases, we end up with an empty string.

\subsection{uninitialized\_copy, uninitalized\_move}

\cppversions{\texttt{uninitialized\_copy}}{\CC98}{N/A}{\CC17}{\CC20}
\cppversions{\texttt{uninitialized\_move}}{\CC17}{N/A}{\CC17}{\CC20}

\constraints{\texttt{input\_range -> forward\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{}{}
\constraints{\texttt{input\_iterator -> forward\_iterator}}{\texttt{forward\_iterator -> forward\_iterator}}{}{}

These algorithms follow the logic of copy and move algorithms. However, because the destination range is uninitialized memory, these turn into copy and move constructions instead copy and move assignments.

\begin{box-note}
\begin{cppcode}
alignas(alignof(std::string)) char buff1[sizeof(std::string)*5];
alignas(alignof(std::string)) char buff2[sizeof(std::string)*5];
std::vector<std::string> data = {"hello", "world", "and", "everyone", "else"};

auto *bg1 = reinterpret_cast<std::string*>(buff1);
std::uninitialized_copy(data.begin(), data.end(), bg1);
// buff1 == { "hello", "world", "and", "everyone", "else"}
// data == { "hello", "world", "and", "everyone", "else"}
std::destroy_n(bg1, 5);

auto *bg2 = reinterpret_cast<std::string*>(buff2);
std::uninitialized_move(data.begin(), data.end(), bg2); 
// buff2 == { "hello", "world", "and", "everyone", "else"}
// data == { ?, ?, ?, ?, ?}
std::destroy_n(bg2, 5);
\end{cppcode}
\end{box-note}

\subsubsection{Transactional behaviour}

The main benefit of using the uninitialized memory algorithms is that they correctly handle transactional behaviour. Transactionality is important in cases where the constructor of an object can throw. If one of the objects fails to construct, the algorithms will correctly roll back by destructing already constructed objects.

We can observe this behaviour by constructing a toy type that throws on the third construction:

\begin{box-note}
\begin{cppcode}
struct Custom {
  static int cnt;
  Custom() { 
    if (++cnt >= 3)
      throw std::runtime_error("Deliberate failure."); 
    std::cout << "Custom()\n";
  }
  ~Custom() {
    std::cout << "~Custom()\n";
  }
};

int Custom::cnt = 0;

alignas(alignof(Custom)) char buffer[sizeof(Custom)*10];
auto *begin = reinterpret_cast<Custom*>(buffer);

try {
  std::uninitialized_default_construct_n(begin, 10);
  std::destroy_n(begin, 10); // not reached
} catch (std::exception& e) {
  std::cout << e.what() << "\n";
}
/* Output:
Custom()
Custom()
~Custom()
~Custom()
Deliberate failure.
*/
\end{cppcode}
\end{box-note}

Because the custom class throws on the constructor’s third call, we will see the std::uninitialized\_default\_construct algorithm create two instances and then immediately destroy two instances of Custom, after which it rethrows the exception.
