\section{Left folds}

Left folds are one of the two big groups of numerical algorithms. Folds operate in a strict order, "folding in" one element at a time by evaluating \cpp{acc = fold_op(acc, el)} for each element. For left folds, the direction of operation is left to right. However, we can easily change the direction for bidirectional ranges since those support reverse iteration.

Because of the strictly linear operation, none of the left-fold algorithms supports a parallel version.

\subsection{\texorpdfstring{\cpp{std::accumulate}}{\texttt{std::accumulate}}}

The \cpp{std::accumulate} algorithm is the single-range left-fold. The default version accumulates using \cpp{operator+}.

\cppversions{\texttt{accumulate}}{\CC98}{\CC20}{N/A}{N/A}
\constraints{\texttt{input\_range}}{}{\texttt{operator +}}{\texttt{binary\_functor}}

\begin{box-note}
\footnotesize Example of using \cpp{std::accumulate}.
\tcblower
\cppfile{code_examples/algorithms/accumulate_code.h}
\end{box-note}

Note that the algorithm accepts an initial value that also dictates the accumulator type.
% TODO: link to chapter about numerical conversions and promotions

\begin{box-note}
\footnotesize Example of using \cpp{std::accumulate} as a right fold.
\tcblower
\cppfile{code_examples/algorithms/accumulate_right_code.h}
\end{box-note}


\subsection{inner\_product}


\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5};
auto left = std::accumulate(data.begin(), data.end(), 0, [](int acc, int el) {
    return acc / 2 + el;
});
auto right = std::accumulate(data.rbegin(), data.rend(), 0, [](int acc, int el) {
    return acc / 2 + el;
});
// left == 8, right == 3
\end{cppcode}
\end{box-note}

By adding another range and a join operation, we arrive at inner\_product. The left fold operation changes to accumulator = op(accumulator, join(elem1, elem2)), where elem1 comes from the first range and elem2 from the second range.

\cppversions{\texttt{inner\_product}}{\CC98}{\CC20}{N/A}{N/A}

\constraints{\texttt{(input\_range, input\_iterator)}}{}{\texttt{operator *, operator +}}{\texttt{(binary\_functor, binary\_functor)}}

The default version uses operator+ for the accumulation and operator* for the join. If specified, neither functor is permitted to modify the elements or invalidate iterators.

\begin{box-note}
\begin{cppcode}
std::vector<int> heights{1, 2, 3, 4, 5};
std::vector<int> widths{2, 3, 4, 5, 6};
auto total_area = std::inner_product(heights.begin(), heights.end(), widths.begin(), 0);
// total_area == 70
\end{cppcode}
\end{box-note}

Naturally, we can also use inner\_product with a single range, for example, to calculate the sum of absolute differences between consecutive elements:

\begin{box-note}
\begin{cppcode}
std::vector<int> data{6, 4, 3, 7, 2, 1};
auto sum_of_diffs = std::inner_product(data.begin(), std::prev(data.end()), 
                                       std::next(data.begin()), 
                                       0, std::plus<>{}, 
                                       [](int left, int right) { return std::abs(left-right); });
// sum_of_diffs == 13
\end{cppcode}
\end{box-note}

\subsection{partial\_sum}

The partial\_sum algorithm is a bit of an outlier here, as it’s not a strict reduction algorithm. Instead, it computes partial sums on the given range. The nth generated element is the sum of the first n elements from the source range.

\cppversions{\texttt{partial\_sum}}{\CC98}{\CC20}{N/A}{N/A}

\constraints{\texttt{input\_range -> output\_iterator}}{}{\texttt{operator+}}{\texttt{binary\_functor}}

The output iterator is permitted to be the input ranges’ begin iterator. The default operation is the binary plus, and a custom functor is not permitted to modify elements or invalidate iterators.

\begin{box-note}
\begin{cppcode}
std::vector<int> data(6, 1);
// data == {1, 1, 1, 1, 1, 1}
std::partial_sum(data.begin(), data.end(), data.begin());
// data == {1, 2, 3, 4, 5, 6}

std::vector<int> out;
std::partial_sum(data.begin(), data.end(), std::back_inserter(out), std::multiplies<>{});
// out == {1, 2, 6, 24, 120, 720}
\end{cppcode}
\end{box-note}
