\section{Left folds}

Left folds are one of the two big groups of numerical algorithms. Folds operate in a strict order, "folding in" one element at a time by evaluating \cpp{acc = fold_op(acc, el)} for each element. For left folds, the direction of operation is left to right. However, we can easily change the direction for bidirectional ranges since those support reverse iteration.

Because of the strictly linear operation, none of the left-fold algorithms supports a parallel version.

\subsection{\texorpdfstring{\cpp{std::accumulate}}{\texttt{std::accumulate}}}

The \cpp{std::accumulate} algorithm is the single-range left-fold.

\cppversions{\texttt{accumulate}}{\CC98}{\CC20}{N/A}{N/A}
\constraints{\texttt{input\_range}}{}{\texttt{operator +}}{\texttt{binary\_functor}}

\begin{box-note}
\footnotesize Example of using \cpp{std::accumulate}.
\tcblower
\cppfile{code_examples/algorithms/accumulate_code.h}
\end{box-note}

Note that the algorithm accepts an initial value that also dictates the accumulator type.
% TODO: link to chapter about numerical conversions and promotions

\begin{box-note}
\footnotesize Example of using \cpp{std::accumulate} as a right fold.
\tcblower
\cppfile{code_examples/algorithms/accumulate_right_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::inner_product}}{\texttt{std::inner\_product}}}

The \cpp{std::inner_product} algorithm is a left fold over two ranges. The pairs of elements are first reduced and then accumulated.

\cppversions{\texttt{inner\_product}}{\CC98}{\CC20}{N/A}{N/A}
\constraints{\texttt{(input\_range, input\_iterator)}}{}{\cpp{operator *}, \cpp{operator +}}{\texttt{(binary\_functor, binary\_functor)}}

The default version uses \cpp{operator*} for the reduction and \cpp{operator+} for the fold operation.

\begin{box-note}
\begin{cppcode}
std::vector<int> heights{1, 2, 3, 4, 5};
std::vector<int> widths{2, 3, 4, 5, 6};
auto total_area = std::inner_product(heights.begin(), heights.end(), widths.begin(), 0);
// total_area == 70
\end{cppcode}
\end{box-note}

Naturally, we can also use inner\_product with a single range, for example, to calculate the sum of absolute differences between consecutive elements:

\begin{box-note}
\begin{cppcode}
std::vector<int> data{6, 4, 3, 7, 2, 1};
auto sum_of_diffs = std::inner_product(data.begin(), std::prev(data.end()), 
                                       std::next(data.begin()), 
                                       0, std::plus<>{}, 
                                       [](int left, int right) { return std::abs(left-right); });
// sum_of_diffs == 13
\end{cppcode}
\end{box-note}

\subsection{partial\_sum}

The partial\_sum algorithm is a bit of an outlier here, as it’s not a strict reduction algorithm. Instead, it computes partial sums on the given range. The nth generated element is the sum of the first n elements from the source range.

\cppversions{\texttt{partial\_sum}}{\CC98}{\CC20}{N/A}{N/A}

\constraints{\texttt{input\_range -> output\_iterator}}{}{\texttt{operator+}}{\texttt{binary\_functor}}

The output iterator is permitted to be the input ranges’ begin iterator. The default operation is the binary plus, and a custom functor is not permitted to modify elements or invalidate iterators.

\begin{box-note}
\begin{cppcode}
std::vector<int> data(6, 1);
// data == {1, 1, 1, 1, 1, 1}
std::partial_sum(data.begin(), data.end(), data.begin());
// data == {1, 2, 3, 4, 5, 6}

std::vector<int> out;
std::partial_sum(data.begin(), data.end(), std::back_inserter(out), std::multiplies<>{});
// out == {1, 2, 6, 24, 120, 720}
\end{cppcode}
\end{box-note}
