\chapter{Introduction}

The \CC standard library is arguably quite limited in its functionality. However, when it comes to data and number crunching, the \CC standard library provides a versatile toolkit of algorithms.

If you are a \CC developer, good familiarity with \CC standard algorithms can save you a lot of effort and accidental bugs. Notably, whenever you see a raw loop in your code, you should question whether calling a standard algorithm wouldn't be a better solution (it usually is).

\section{History of standard \texorpdfstring{\CC}{C++} algorithms}

While each \CC standard introduced new algorithms or variants, there are few notable milestones in the history of \CC standard algorithms.

The \CC98 standard introduced most of the algorithms. However, it was the \CC11 standard with its introduction of lambdas that made algorithms worthwhile. Before lambdas, the time investment of writing a custom function object made the usefulness of algorithms dubious.

\begin{box-note}
\footnotesize Example of \mintinline{cpp}{std::for_each}\index{\mintinline{cpp}{std::for_each}} algorithm with a custom function object, calculating the number of elements and their sum.
\tcblower
\cppfile{code_examples/introduction/history_cc98_code.h}
\end{box-note}

\begin{box-note}
\footnotesize Example of \mintinline{cpp}{std::for_each}\index{\mintinline{cpp}{std::for_each}} algorithm with a capturing lambda, calculating the number of elements and their sum.
\tcblower
\cppfile{code_examples/introduction/history_cc11_code.h}
\end{box-note}

The \CC17 standard introduced parallel algorithms that provide an easy way to speed up processing with minimal effort. All you need to do is to specify the desired execution model, and the library will take care of spawning the correct number of threads.

\begin{box-note}
\footnotesize Example of \mintinline{cpp}{std::for_each}\index{\mintinline{cpp}{std::for_each}} algorithm using unsequenced parallel execution model. Note that counters are now shared state and need to be \mintinline{cpp}{std::atomic}\index{\mintinline{cpp}{std::atomic}} or protected by a \mintinline{cpp}{std::mutex}\index{\mintinline{cpp}{std::mutex}}.
\tcblower
\cppfile{code_examples/introduction/history_cc17_code.h}
\end{box-note}

Finally, the \CC20 standard introduced a significant re-design in the form of ranges and views. Range versions of algorithms can now operate on ranges instead of \mintinline{cpp}{begin} and \mintinline{cpp}{end} iterators and views provide lazily evaluated versions of algorithms and utilities.

\begin{box-note}
\footnotesize Example of the range version of the \mintinline{cpp}{std::for_each}\index{\mintinline{cpp}{std::for_each}} algorithm.
\tcblower
\cppfile{code_examples/introduction/history_cc20_code.h}
\end{box-note}

As of the time of writing, the \CC23 is not finalized. However, we already know that it will introduce more range algorithms, more views and the ability to implement custom views.

\section{Iterators and ranges}

Algorithms operate on data structures, which poses an issue. How do you abstract the implementation details of a specific data structure and allow the algorithm to work with any data structure that satisfies the algorithm's requirements?

The \CC standard library solution to this problem are iterators and ranges. Iterators encapsulate implementation details of data structure traversal and simultaneously expose a set of operations possible on the given data structure in constant time and space.

A range is then denoted by a pair of iterators, or more generally, since \CC20, an iterator and a sentinel.

In mathematical terms, a pair of iterators $it1$, $it2$ denotes a range $[it1, it2)$, that is, the range includes the element referenced by $it1$ and ends before the element referenced by $it2$.



Sentinels follow the same idea. However, they do not need to be of an iterator type. Instead, they only need to be comparable to an iterator. The end of the range is then the first iterator that compares equal to the sentinel.

Example of specifying a range using an iterator and custom sentinel. The sentinel will compare true with iterators at least the given distance from the start iterator, therefore defining a range with the specified number of elements.


At the core that lies between C++ data structures and algorithms are iterators. Iterators abstract away the details of how a particular data structure is traversed while capturing the behavioural limitations that a data structure imposes.

For example, an array (e.g. \emph{\index{std::vector}}) allows random access, meaning that we can move from one element to another in constant time. On the other hand, a linked list (e.g. std::list) only allows us to move to the next and previous elements in constant time, and moving the distance of n takes n operations (linear complexity).

\subsection{Iterator categories}

C++ recognizes the following categories of iterators:

\begin{itemize}
    \item \gls{input iterator}: advance, read, one pass
    \item \gls{forward iterator}: advance, read
    \item \gls{bidirectional iterator}: forward iterator + move back
    \item \gls{random access iterator}: bidirectional iterator + advance \& move back by any integer, calculate distance between two iterators
    \item \gls{contiguous iterator}: random access + the storage of elements is contiguous
    \item \gls{output iterator}: advance, write, one pass
\end{itemize}

\begin{box-note}
\begin{cppcode}
std::vector<int> vec{1,2,3,4,5,6};
auto it = vec.begin();
it += 5; // *it == 6
\end{cppcode}
\noindent\small\texttt{std::vector} provides a continuous access iterator (since C++20), random access iterator (before C++20).
\end{box-note}

\begin{box-note}
\begin{cppcode}
std::list<int> lst{1,2,3,4,5,6};
auto it = lst.begin();
// it += 5; Doesn't compile
std::advance(it, 5); // linear advance, *it == 6
\end{cppcode}
\noindent\small\texttt{std::list} only provides a bidirectional iterator.
\end{box-note}

This categorization allows algorithms to specify the type of iterator they require, either explicitly (using C++20 concepts) or implicitly by using operations supported by a specific kind of iterator.

For example, \emph{\index{std::sort}} requires random access iterators because it needs to calculate the distance of two iterators efficiently. Therefore the following code will not compile (std::list provides bidirectional iterators):

\begin{box-note}
\begin{cppcode}
std::list<int> data = { 9, 1, 8, 2, 7, 3};
std::sort(data.begin(), data.end()); // will not compile
\end{cppcode}
\end{box-note}

\section{Ranges}

While C++20 formalized the concept of a range, the notion of a range was present in C++ since the beginning. Each container is expected to provide access to two iterators, begin and end. The semantic here is [begin,end), that is, begin is an iterator to the first element, end is an iterator one past the last element.

\begin{box-note}
\begin{cppcode}
std::vector<int> v{1,2,3,4,5,6};
for (auto it = v.begin(); it != v.end(); it++) {
    std::cout << *it << "\n";
}
\end{cppcode}
\end{box-note}

Ranges can be classified using the same categories of iterators. In this series, we will be using the range nomenclature over iterators (e.g. input range, forward range, bidirectional range, etc.).

\section{for\_each, for\_each\_n}

Enough of theory. Let’s talk specific algorithms, and we will start with the simplest of all, for\_each and for\_each\_n.

\cppversions{\texttt{for\_each}}{\CC98}{\CC20}{\CC17}{\CC20}
\constraints{\texttt{input\_range}}{}{N/A}{\texttt{unary\_invocable}}

Since C++11 introduced a range loop, for\_each became a less relevant algorithm. However, there are still a couple of situations where for\_each offers a lot of functionality.

The parallel version is probably the most straightforward parallel facility in C++. If all you need is to run an expensive operation on each element in isolation, a parallel for\_each is the perfect solution:

\begin{box-note}
\begin{cppcode}
std::vector<int> data = get_data();
std::for_each(std::execution::par_unseq, 
    data.begin(), data.end(),
    [](int e) { /* some expensive computation */ });
\end{cppcode}
\end{box-note}

Note that if the operations are not entirely isolated, you will need additional synchronization inside the lambda.

The range version can offer more concise code if all you need is to project an element and then dispatch the result to another function. Here, we have the same code expressed using for\_each and a range loop:

\begin{box-note}
\begin{cppcode}
struct Elem {
    double value() { return 10.2; }
};

void some_function(double);

int main() {
    std::vector<Elem> data(10, Elem{});
    
    std::ranges::for_each(data, some_function, &Elem::value);

    for(auto& e: data) {
        some_function(e.value());
    }
}
\end{cppcode}
\end{box-note}

In the range version (line 10), the first parameter is the range, the second parameter is the function we want to call for each element, and the third is the projection. In this case, we use a member pointer. I have a separate article on C++20 ranges if you want to dig into the details.

\cppversions{\texttt{for\_each\_n}}{\CC17}{\CC20}{\CC17}{\CC20}
\constraints{
    \texttt{(input\_iterator, iter\_difference)}}{
    \texttt{(forward\_iterator, iter\_difference)}}{
    N/A}{
    \texttt{unary\_invocable}}

While for\_each operates on the entire range, the interval [begin, end), for\_each\_n operates on the range [first, first+n). Importantly, because the algorithm doesn’t even have access to the end iterator of the source range, it does no out-of-bounds checking, and it is the responsibility of the caller to ensure that the [first,first+n) range is valid.

For demonstration, let’s look at a piece of code that evaluates a qualification round in a tournament. We want to invite the top players to the main tournament and then post the final score online, paginated by 100 entries:

\begin{box-note}
\begin{cppcode}
struct Player {
    std::string display_name;
    std::string contact_email;
    uint32_t score;
};

std::vector<Player> get_ranking();
void send_invitation_to_main_tournament(const Player& player);
void store_final_score(uint32_t page, const std::string& name, uint32_t score);

inline constexpr const ssize_t MAIN_TOURNAMENT_SEATS = 10;
inline constexpr const ssize_t PAGE_SCORE_SIZE = 100;

int main() {
    std::vector<Player> final_ranking = get_ranking();
    std::ranges::sort(final_ranking, std::greater<>(), 
                      &Player::score);

    std::for_each_n(std::execution::par_unseq, 
        final_ranking.begin(), 
        std::min(MAIN_TOURNAMENT_SEATS, final_ranking.size()),
        send_invitation_to_main_tournament);
    
    auto it = final_ranking.begin();
    uint32_t page = 0;
    while (it != final_ranking.end()) {
        ssize_t cnt = std::min(PAGE_SCORE_SIZE, final_ranking.end()-it);
        std::for_each_n(it, cnt, [page](const Player& p) {
            store_final_score(page, p.display_name, p.score);
        });
        page++;
        it += cnt;
    }
}
\end{cppcode}
\end{box-note}

Sending invitations can be done in parallel (line 18), but we must avoid going out of bounds (std::min on line 19). For pagination, we go in chunks of PAGE\_SCORE\_SIZE, and for each chunk, invoke for\_each\_n (line 26).