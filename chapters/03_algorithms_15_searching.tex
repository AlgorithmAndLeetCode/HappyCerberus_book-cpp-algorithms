\section{Search and compare algorithms}

The search and compare category provides straightforward linear (when compared against a single value) and quadratic (when compared against a range) complexity algorithms.

\subsection{\texorpdfstring{\cpp{std::find}, \cpp{std::find_if}, \cpp{std::find_if_not}}{\texttt{std::find}, \texttt{std::find\_if}, \texttt{std::find\_if\_not}}}

The std::find algorithm provides a basic linear search. The standard provides three variants, one searching by value and two variants using a predicate.

\cppversions{\texttt{find, find\_if}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{find\_if\_not}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{\texttt{operator==} (\texttt{find})}{\texttt{unary\_predicate}}

A typical example of searching by value is finding delimiters:

\begin{box-note}
\footnotesize Example of utilizing \cpp{std::find} to find delimiters in a string.
\tcblower
\cppfile{code_examples/algorithms/find_code.h}
\end{box-note}

If we want to search for categories of elements, we can use \cpp{std::find_if} and \cpp{std::find_if_not} since these two variants search using a predicate.

\begin{box-note}
\footnotesize Example of utilizing \cpp{std::find_if_not} to find leading and trailing whitespace.
\tcblower
\cppfile{code_examples/algorithms/find_if_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::adjacent_find}}{\texttt{std::adjacent\_find}}}

The \cpp{std::adjacent_find} is a binary find algorithm that searches for pairs of adjacent elements in a single range.

\cppversions{\texttt{adjacent\_find}}{\CC98}{\CC20}{\CC17}{\CC20}
\constraints{\texttt{forward\_range}}{\texttt{forward\_range}}{\texttt{operator==}}{\texttt{binary\_predicate}}

If the algorithm finds a pair of elements, it will return an iterator to the first of the two elements (end iterator otherwise).

\begin{box-note}
\footnotesize Example of using \cpp{std::adjacent_find} to find the first pair of equal elements and the first pair of elements that sum up to more than ten.
\tcblower
\cppfile{code_examples/algorithms/adjacent_find_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::search_n}}{\texttt{std::search\_n}}}

The \cpp{std::search_n} algorithm searches for n instances of the given value.

\cppversions{\texttt{search\_n}}{\CC98}{\CC20}{\CC17}{\CC20}
\constraints{\texttt{forward\_range}}{\texttt{forward\_range}}{\texttt{operator==}}{\texttt{binary\_predicate}}

The interface to \cpp{std::search_n} can be a bit confusing. The algorithm accepts the number of instances and the value to search for as two consecutive arguments, followed by an optional custom comparator function.

\begin{box-note}
\footnotesize Example of using \cpp{std::search_n} to find two consecutive elements equal to $3$, three elements equal to $3$ (in modulo $5$ arithmetic) and finally, two elements equal to $0$.
\tcblower
\cppfile{code_examples/algorithms/search_n_code.h}
\end{box-note}

Note that \cpp{std::search_n} is one exception to the \cpp{_n} naming scheme.

\subsection{\texorpdfstring{\cpp{std::find_first_of}}{\texttt{std::find\_first\_of}}}

Using \cpp{std::find_if}, we can easily search for a category of elements. However, sometimes it is more convenient to list the elements we are looking for exhaustively.

\cppversions{\texttt{find\_first\_of}}{\CC98}{\CC20}{\CC17}{\CC20}
\constraints{\texttt{(input\_range, forward\_range)}}{\texttt{(forward\_range, forward\_range)}}{\texttt{operator==}}{\texttt{binary\_predicate}}

Note that we are shifting from linear search to $O(m*n)$ time complexity since, for each element of the first range, we need to compare it to all elements in the second range (worst case).

\begin{box-note}
\footnotesize Example of using \cpp{std::find_first_of}.
\tcblower
\cppfile{code_examples/algorithms/find_first_of_code.h}
\end{box-note}

\subsection{\texorpdfstring{\cpp{std::search}, \cpp{std::find_end}}{\texttt{std::search}, \texttt{std::find\_end}}}

Both \cpp{std::search} and \cpp{std::find_end} algorithms search for a sub-sequence in a sequence.
The \cpp{std::search} algorithm will return the first instance, and \cpp{std::find_end} will return the last.

\cppversions{\texttt{search, find\_end}}{\CC98}{\CC20}{\CC17}{\CC20}
\constraints{\texttt{(forward\_range, forward\_range)}}{\texttt{(forward\_range, forward\_range)}}{\texttt{operator==}}{\texttt{binary\_predicate}}

\begin{box-note}
\footnotesize Example of using \cpp{std::search} and \cpp{std::find_end}.
\tcblower
\cppfile{code_examples/algorithms/search_code.h}
\end{box-note}

\subsubsection{Searchers}

Since C++17, we also can specify custom searchers for the search algorithm. Apart from the basic one, the standard implements Boyer-Moore and Boyer-Moore-Horspool string searchers that offer different best-case, worst-case and average complexity.

\begin{box-note}
\begin{cppcode}
std::string haystack = "abbabba";
std::string needle = "bba";

auto it1 = std::search(haystack.begin(), haystack.end(), 
                       std::default_searcher(needle.begin(), needle.end()));

auto it2 = std::search(haystack.begin(), haystack.end(), 
                       std::boyer_moore_searcher(needle.begin(), needle.end()));

auto it3 = std::search(haystack.begin(), haystack.end(), 
                       std::boyer_moore_horspool_searcher(needle.begin(), needle.end()));
// it1 == it2 == it3
\end{cppcode}
\end{box-note}

\subsection{count, count\_if}

The std::count and std::count\_if algorithms count the number of matching elements.

\cppversions{\texttt{count, count\_if}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{\texttt{operator==} (\texttt{count})}{\texttt{unary\_predicate} (\texttt{count\_if})}

The element searched for can be specified using a value or a predicate.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 1, 2, 3, 2, 1, 2, 3, 2, 1 };
auto one_cnt = std::count(data.begin(), data.end(), 1);
// one_cnt == 3

auto even_cnt = std::count_if(data.begin(), data.end(), 
                              [](int v) { return v % 2 == 0; });
// even_cnt == 4
\end{cppcode}
\end{box-note}

\subsection{equal, mismatch}

In a previous article, we discussed lexicographical comparisons using std::lexicographical\_compare and std::lexicographical\_compare\_three\_way. The std::equal and std::mismatch algorithms provide a simpler equality comparison, with std::equal returning a simple boolean and std::mismatch returning a pair of iterators denoting the mismatching elements.

\cppversions{\texttt{equal, mismatch}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(input\_range, input\_iterator)}}{\texttt{(forward\_range, forward\_iterator)}}{\texttt{operator==}}{\texttt{binary\_predicate}}
\constraints{\texttt{(input\_range, input\_range)} since \CC14}{(forward\_range, forward\_range)}{\texttt{operator==}}{\texttt{binary\_predicate}}

The default operator== can be replaced by a binary predicate for both algorithms.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { -1, -2, -3, -4, -5 };

assert(!std::equal(first.begin(), first.end(), second.begin()));

assert(std::equal(first.begin(), first.end(), second.begin(), 
                  [](int l, int r) { return std::abs(l) == std::abs(r); }));
\end{cppcode}
\end{box-note}

The std::mismatch algorithm returns a pair of iterators whose underlying elements do not match.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { 1, 2, 2, 4, 5 };

auto it_pair = std::mismatch(first.begin(), first.end(), second.begin());
// *it_pair.first == 3, *it_pair.second == 2
\end{cppcode}
\end{box-note}

Both std::equal and std::mismatch provide two variants of specifying the second range. The distinction is important here. If we specify the second range using an iterator, we cannot detect a mismatch in the size of the ranges.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { 1, 2, 3, 4, 5, 6 };

assert(std::equal(first.begin(), first.end(), 
                  second.begin()));
// Cannot detect mismatch in size.

assert(!std::equal(first.begin(), first.end(), 
                   second.begin(), second.end()));
// Different number of elements -> not equal.
\end{cppcode}
\end{box-note}