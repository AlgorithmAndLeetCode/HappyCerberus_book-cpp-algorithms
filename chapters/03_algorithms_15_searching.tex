\section{Search and compare algorithms}

The search and compare category provides straightforward linear (when compared against a single value) and quadratic (when compared against a range) complexity algorithms.

\subsection{\texorpdfstring{\cpp{std::find}, \cpp{std::find_if}, \cpp{std::find_if_not}}{\texttt{std::find}, \texttt{std::find\_if}, \texttt{std::find\_if\_not}}}

The std::find algorithm provides a basic linear search. The standard provides three variants, one searching by value and two variants using a predicate.

\cppversions{\texttt{find, find\_if}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{find\_if\_not}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{\texttt{operator==} (\texttt{find})}{\texttt{unary\_predicate}}

A typical example of searching by value is finding delimiters:

\begin{box-note}
\footnotesize Example of utilizing \cpp{std::find} to find delimiters in a string.
\tcblower
\cppfile{code_examples/algorithms/find_code.h}
\end{box-note}

If we want to search for categories of elements, we can use \cpp{std::find_if} and \cpp{std::find_if_not} since these two variants search using a predicate.

\begin{box-note}
\footnotesize Example of utilizing \cpp{std::find_if_not} to find leading and trailing whitespace.
\tcblower
\cppfile{code_examples/algorithms/find_if_code.h}
\end{box-note}

\subsection{adjacent\_find, search\_n}

As the name suggests, std::adjacent\_find searches for adjacent elements in the range.

\cppversions{\texttt{adjacent\_find}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

The basic version searches for a pair of adjacent elements using operator== or the binary predicate if provided. In either case, the pair will be returned by an iterator to the first of the two elements.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 1, 2, 3, 4, 4, 5, 6, 7, 8, 9 };
auto it1 = std::adjacent_find(data.begin(), data.end());
// *it1 == 4, i.e. {4, 4}

auto it2 = std::adjacent_find(data.begin(), data.end(), 
                              [](int l, int r) { return l + r > 10; });
// *it2 == 5, i.e. {5, 6}
\end{cppcode}
\end{box-note}

If we want to search for more than two consecutive equal elements, we can use std::search\_n.

\cppversions{\texttt{search\_n}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

The algorithm accepts the desired number of instances and the value to compare against. If found, the sequence is returned using an iterator to the first element of the sequence.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 1, 0, 5, 8, 3, 3, 2 };

auto it1 = std::search_n(data.begin(), data.end(), 2, 3);
// *it1 == 3, i.e. {3, 3}

auto it2 = std::search_n(data.begin(), data.end(), 3, 3, 
                         [](int l, int r) { return l % 5 == r % 5; });
// *it2 == 8, i.e. {8, 3, 3}

auto it3 = std::search_n(data.begin(), data.end(), 2, 0);
// it3 == data.end(), i.e. not found
\end{cppcode}
\end{box-note}

Note that the behaviour of std::search\_n does not match the typical naming. The range is still specified entirely using a begin and end iterator. The \_n refers to the number of instances instead.

\subsection{find\_first\_of}

Using std::find\_if, we can easily search for a category of elements. However, sometimes it is more convenient to list the elements we are looking for exhaustively.

\cppversions{\texttt{find\_first\_of}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(input\_range, forward\_range)}}{\texttt{(forward\_range, forward\_range)}}{\texttt{operator==}}{\texttt{binary\_predicate}}

Note that we are shifting from linear search to O(m*n) time complexity since, for each element of the first range, we need to compare it to all elements in the second range (worst case).

\begin{box-note}
\begin{cppcode}
std::vector<int> haystack = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
std::vector<int> needles = { 7, 5, 3 };
auto it = std::find_first_of(haystack.begin(), haystack.end(), 
                             needles.begin(), needles.end());
// *it == 3, i.e. haystack[2]
\end{cppcode}
\end{box-note}

\subsection{search, find\_end}

Finally, we arrive at algorithms that search for a sub-sequence in a sequence.

\cppversions{\texttt{search, find\_end}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(forward\_range, forward\_range)}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

The std::search returns the first instance of the sub-sequence, and std::find\_end returns the last instance of the sub-sequence.

\begin{box-note}
\begin{cppcode}
std::string haystack = "abbabba";
std::string needle = "bba";
auto it1 = std::search(haystack.begin(), haystack.end(), 
                       needle.begin(), needle.end());
// it1..end == "bbabba"

auto it2 = std::find_end(haystack.begin(), haystack.end(), 
                         needle.begin(), needle.end());
// it2..end == "bba"
\end{cppcode}
\end{box-note}

\subsubsection{Searchers}

Since C++17, we also can specify custom searchers for the search algorithm. Apart from the basic one, the standard implements Boyer-Moore and Boyer-Moore-Horspool string searchers that offer different best-case, worst-case and average complexity.

\begin{box-note}
\begin{cppcode}
std::string haystack = "abbabba";
std::string needle = "bba";

auto it1 = std::search(haystack.begin(), haystack.end(), 
                       std::default_searcher(needle.begin(), needle.end()));

auto it2 = std::search(haystack.begin(), haystack.end(), 
                       std::boyer_moore_searcher(needle.begin(), needle.end()));

auto it3 = std::search(haystack.begin(), haystack.end(), 
                       std::boyer_moore_horspool_searcher(needle.begin(), needle.end()));
// it1 == it2 == it3
\end{cppcode}
\end{box-note}

\subsection{count, count\_if}

The std::count and std::count\_if algorithms count the number of matching elements.

\cppversions{\texttt{count, count\_if}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{\texttt{operator==} (\texttt{count})}{\texttt{unary\_predicate} (\texttt{count\_if})}

The element searched for can be specified using a value or a predicate.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 1, 2, 3, 2, 1, 2, 3, 2, 1 };
auto one_cnt = std::count(data.begin(), data.end(), 1);
// one_cnt == 3

auto even_cnt = std::count_if(data.begin(), data.end(), 
                              [](int v) { return v % 2 == 0; });
// even_cnt == 4
\end{cppcode}
\end{box-note}

\subsection{equal, mismatch}

In a previous article, we discussed lexicographical comparisons using std::lexicographical\_compare and std::lexicographical\_compare\_three\_way. The std::equal and std::mismatch algorithms provide a simpler equality comparison, with std::equal returning a simple boolean and std::mismatch returning a pair of iterators denoting the mismatching elements.

\cppversions{\texttt{equal, mismatch}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(input\_range, input\_iterator)}}{\texttt{(forward\_range, forward\_iterator)}}{\texttt{operator==}}{\texttt{binary\_predicate}}
\constraints{\texttt{(input\_range, input\_range)} since \CC14}{(forward\_range, forward\_range)}{\texttt{operator==}}{\texttt{binary\_predicate}}

The default operator== can be replaced by a binary predicate for both algorithms.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { -1, -2, -3, -4, -5 };

assert(!std::equal(first.begin(), first.end(), second.begin()));

assert(std::equal(first.begin(), first.end(), second.begin(), 
                  [](int l, int r) { return std::abs(l) == std::abs(r); }));
\end{cppcode}
\end{box-note}

The std::mismatch algorithm returns a pair of iterators whose underlying elements do not match.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { 1, 2, 2, 4, 5 };

auto it_pair = std::mismatch(first.begin(), first.end(), second.begin());
// *it_pair.first == 3, *it_pair.second == 2
\end{cppcode}
\end{box-note}

Both std::equal and std::mismatch provide two variants of specifying the second range. The distinction is important here. If we specify the second range using an iterator, we cannot detect a mismatch in the size of the ranges.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { 1, 2, 3, 4, 5, 6 };

assert(std::equal(first.begin(), first.end(), 
                  second.begin()));
// Cannot detect mismatch in size.

assert(!std::equal(first.begin(), first.end(), 
                   second.begin(), second.end()));
// Different number of elements -> not equal.
\end{cppcode}
\end{box-note}