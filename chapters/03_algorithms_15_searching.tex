\section{Searching and min-max}

The search and min-max algorithms we will cover today all operate linearly with O(n) (when operating on a single range) or O(m*n) complexity (when operating on two ranges). We have covered faster lookup algorithms in article number three.

\subsection{find, find\_if, find\_if\_not}

The std::find algorithm provides a basic linear search. The standard provides three variants, one searching by value and two variants using a predicate.

\cppversions{\texttt{find, find\_if}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{find\_if\_not}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{\texttt{operator==} (\texttt{find})}{\texttt{unary\_predicate}}

A typical example of searching by value is finding delimiters:

\begin{box-note}
\begin{cppcode}
std::string data = "John;Doe;April;1;1900;";
auto it = data.begin(), token = data.begin();
std::vector<std::string> out;

while ((token = find(it, data.end(), ';')) != data.end()) {
    out.push_back("");
    std::copy(it, token, std::back_inserter(out.back()));
    it = std::next(token);
}
// out == { "John", "Doe", "April", "1", "1900" }
\end{cppcode}
\end{box-note}

Because std::find\_if and std::find\_if\_not compare elements using a predicate, we can search for categories of values. In this example, we use std::find\_if\_not to find the first non-white-space character from either direction:

\begin{box-note}
\begin{cppcode}
std::string data = "   hello world!  ";
auto begin = std::find_if_not(data.begin(), data.end(), 
                              [](char c) { return isspace(c); });
if (begin == data.end()) // only spaces
    return 0;

std::string out;
std::copy(begin, std::find_if_not(data.rbegin(), data.rend(), 
                                  [](char c) { return isspace(c); }).base(), 
          std::back_inserter(out));
// out == "hello world!"
\end{cppcode}
\end{box-note}

\subsection{adjacent\_find, search\_n}

As the name suggests, std::adjacent\_find searches for adjacent elements in the range.

\cppversions{\texttt{adjacent\_find}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

The basic version searches for a pair of adjacent elements using operator== or the binary predicate if provided. In either case, the pair will be returned by an iterator to the first of the two elements.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 1, 2, 3, 4, 4, 5, 6, 7, 8, 9 };
auto it1 = std::adjacent_find(data.begin(), data.end());
// *it1 == 4, i.e. {4, 4}

auto it2 = std::adjacent_find(data.begin(), data.end(), 
                              [](int l, int r) { return l + r > 10; });
// *it2 == 5, i.e. {5, 6}
\end{cppcode}
\end{box-note}

If we want to search for more than two consecutive equal elements, we can use std::search\_n.

\cppversions{\texttt{search\_n}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

The algorithm accepts the desired number of instances and the value to compare against. If found, the sequence is returned using an iterator to the first element of the sequence.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 1, 0, 5, 8, 3, 3, 2 };

auto it1 = std::search_n(data.begin(), data.end(), 2, 3);
// *it1 == 3, i.e. {3, 3}

auto it2 = std::search_n(data.begin(), data.end(), 3, 3, 
                         [](int l, int r) { return l % 5 == r % 5; });
// *it2 == 8, i.e. {8, 3, 3}

auto it3 = std::search_n(data.begin(), data.end(), 2, 0);
// it3 == data.end(), i.e. not found
\end{cppcode}
\end{box-note}

Note that the behaviour of std::search\_n does not match the typical naming. The range is still specified entirely using a begin and end iterator. The \_n refers to the number of instances instead.

\subsection{find\_first\_of}

Using std::find\_if, we can easily search for a category of elements. However, sometimes it is more convenient to list the elements we are looking for exhaustively.

\cppversions{\texttt{find\_first\_of}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(input\_range, forward\_range)}}{\texttt{(forward\_range, forward\_range)}}{\texttt{operator==}}{\texttt{binary\_predicate}}

Note that we are shifting from linear search to O(m*n) time complexity since, for each element of the first range, we need to compare it to all elements in the second range (worst case).

\begin{box-note}
\begin{cppcode}
std::vector<int> haystack = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
std::vector<int> needles = { 7, 5, 3 };
auto it = std::find_first_of(haystack.begin(), haystack.end(), 
                             needles.begin(), needles.end());
// *it == 3, i.e. haystack[2]
\end{cppcode}
\end{box-note}

\subsection{search, find\_end}

Finally, we arrive at algorithms that search for a sub-sequence in a sequence.

\cppversions{\texttt{search, find\_end}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(forward\_range, forward\_range)}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

The std::search returns the first instance of the sub-sequence, and std::find\_end returns the last instance of the sub-sequence.

\begin{box-note}
\begin{cppcode}
std::string haystack = "abbabba";
std::string needle = "bba";
auto it1 = std::search(haystack.begin(), haystack.end(), 
                       needle.begin(), needle.end());
// it1..end == "bbabba"

auto it2 = std::find_end(haystack.begin(), haystack.end(), 
                         needle.begin(), needle.end());
// it2..end == "bba"
\end{cppcode}
\end{box-note}

\subsubsection{Searchers}

Since C++17, we also can specify custom searchers for the search algorithm. Apart from the basic one, the standard implements Boyer-Moore and Boyer-Moore-Horspool string searchers that offer different best-case, worst-case and average complexity.

\begin{box-note}
\begin{cppcode}
std::string haystack = "abbabba";
std::string needle = "bba";

auto it1 = std::search(haystack.begin(), haystack.end(), 
                       std::default_searcher(needle.begin(), needle.end()));

auto it2 = std::search(haystack.begin(), haystack.end(), 
                       std::boyer_moore_searcher(needle.begin(), needle.end()));

auto it3 = std::search(haystack.begin(), haystack.end(), 
                       std::boyer_moore_horspool_searcher(needle.begin(), needle.end()));
// it1 == it2 == it3
\end{cppcode}
\end{box-note}

\subsection{count, count\_if}

The std::count and std::count\_if algorithms count the number of matching elements.

\cppversions{\texttt{count, count\_if}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{\texttt{operator==} (\texttt{count})}{\texttt{unary\_predicate} (\texttt{count\_if})}

The element searched for can be specified using a value or a predicate.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 1, 2, 3, 2, 1, 2, 3, 2, 1 };
auto one_cnt = std::count(data.begin(), data.end(), 1);
// one_cnt == 3

auto even_cnt = std::count_if(data.begin(), data.end(), 
                              [](int v) { return v % 2 == 0; });
// even_cnt == 4
\end{cppcode}
\end{box-note}

\subsection{equal, mismatch}

In a previous article, we discussed lexicographical comparisons using std::lexicographical\_compare and std::lexicographical\_compare\_three\_way. The std::equal and std::mismatch algorithms provide a simpler equality comparison, with std::equal returning a simple boolean and std::mismatch returning a pair of iterators denoting the mismatching elements.

\cppversions{\texttt{equal, mismatch}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(input\_range, input\_iterator)}}{\texttt{(forward\_range, forward\_iterator)}}{\texttt{operator==}}{\texttt{binary\_predicate}}
\constraints{\texttt{(input\_range, input\_range)} since \CC14}{(forward\_range, forward\_range)}{\texttt{operator==}}{\texttt{binary\_predicate}}

The default operator== can be replaced by a binary predicate for both algorithms.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { -1, -2, -3, -4, -5 };

assert(!std::equal(first.begin(), first.end(), second.begin()));

assert(std::equal(first.begin(), first.end(), second.begin(), 
                  [](int l, int r) { return std::abs(l) == std::abs(r); }));
\end{cppcode}
\end{box-note}

The std::mismatch algorithm returns a pair of iterators whose underlying elements do not match.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { 1, 2, 2, 4, 5 };

auto it_pair = std::mismatch(first.begin(), first.end(), second.begin());
// *it_pair.first == 3, *it_pair.second == 2
\end{cppcode}
\end{box-note}

Both std::equal and std::mismatch provide two variants of specifying the second range. The distinction is important here. If we specify the second range using an iterator, we cannot detect a mismatch in the size of the ranges.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { 1, 2, 3, 4, 5, 6 };

assert(std::equal(first.begin(), first.end(), 
                  second.begin()));
// Cannot detect mismatch in size.

assert(!std::equal(first.begin(), first.end(), 
                   second.begin(), second.end()));
// Different number of elements -> not equal.
\end{cppcode}
\end{box-note}

\subsection{clamp}

The std::clamp algorithm is one of the few algorithms that do not operate on ranges.

\cppversions{\texttt{clamp}}{\CC17}{\CC17}{N/A}{\CC20}

The clamp algorithm will clamp the given value in between the provided minimum and maximum:

\begin{itemize}
    \item if $value < minimum$, std::clamp returns the minimum
    \item if $maximum < value$, std::clamp returns the maximum
    \item otherwise, std::clamp returns the value
\end{itemize}

\begin{box-note}
\begin{cppcode}
int a = std::ranges::clamp(10, 0, 20);
// a == 10 (0 < 10 && 10 < 20)

int b = std::clamp(-20, 0, 20);
// b == 0 (-20 < 0)

int c = std::clamp(30, 0, 20);
// c == 20 ( 30 > 20 )
\end{cppcode}
\end{box-note}

\subsection{min, max, minmax}

The first group of min-max algorithms also do not operate on ranges (except a C++20 range variant).

\cppversions{\texttt{min, max}}{\CC98}{\CC14}{N/A}{\CC20}
\cppversions{\texttt{minmax}}{\CC11}{\CC14}{N/A}{\CC20}

\constraints{\texttt{initializer\_list} since \CC14}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}
\constraints{\texttt{input\_range} \CC20 range version only}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

Until C++14, the only variants available operated on two elements only, returning a const-reference. Then, the C++14 standard introduced a variant that operates on an initializer list, which returns by value. Finally, C++20 introduced a range variant that operates on input ranges and returns by value.

\begin{box-note}
\begin{cppcode}
auto i = std::min(1, 2);
// i == 1

auto j = std::max(1, 2);
// j == 2

auto v = std::minmax({5, 3, -2, 0});
// v.first == -2, v.second == 5

std::list<int> data = {5, 3, -2, 0};
auto k = std::ranges::min(data);
// k == -2
\end{cppcode}
\end{box-note}

\subsection{min\_element, max\_element, minmax\_element}

The element versions of min-max algorithms operate on ranges and, instead of returning by const-reference or value, return an iterator to the minimum or maximum elements.

\cppversions{\texttt{min\_element, max\_element}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{minmax\_element}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

All variants require forward\_range as they return iterators to the min-max elements instead of a value.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 5, 3, -2 , 0};
auto i = std::min_element(data.begin(), data.end());
// *i == -2 (i.e. data[2])
auto j = std::max_element(data.begin(), data.end());
// *j == 5 (i.e. data[0])

auto k = std::minmax_element(data.begin(), data.end());
// *k.first == -2, *k.second == 5
\end{cppcode}
\end{box-note}