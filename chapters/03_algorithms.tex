\chapter{The algorithms}

\section{Swaps}

\section{swap, swap\_ranges, iter\_swap}

The second group of algorithms we will discuss today is the group of swaps.

\cppversions{\texttt{swap}}{\CC98}{\CC20}{N/A}{\CC20} % TODO noexcept change in C++11

However, we first need to discuss a little complexity arising from argument dependent lookup. It is not unusual when data structures are cheap to swap, so we will want to customize swap for them.

We can specialize std::swap inside the std namespace, but that would mean that this specialization will not be matched using argument dependent lookup (it would live in a different namespace than its parameters). That means that an unqualified call to swap would not find the correct implementation.

The proper way to specialize swap is to provide a (friend) function in the same namespace as the data structure:

\begin{box-note}
\begin{cppcode}
namespace SomeLib {

struct SomeStruct {
    std::vector<int> data;

    friend void swap(SomeStruct& left, SomeStruct& right) {
        left.data.swap(right.data);
    }
};

}
\end{cppcode}
\end{box-note}

And the proper way to call swap is to pull in the std::swap before the unqualified call:

\begin{box-note}
\begin{cppcode}
void some_algorithm(auto& a, auto& b) {
    using std::swap;
    swap(a, b);
}
\end{cppcode}
\end{box-note}

Fortunately, the C++20 rangified version of swap removes this complexity. It serves as an ultimate solution it will:

\begin{itemize}
    \item will call the user-provided or standard swap matching the types
    \item if that doesn’t exist and the parameters are ranges, will do swap\_range
    \item if the parameters aren’t ranges, it will default to a move swap\\
    \mintinline{cpp}{V v(std::move(t)); t = std::move(u); u = std::move(v);}
\end{itemize}

\begin{box-note}
\begin{cppcode}
namespace Library {
struct Storage {
    int value;
};

void swap(Storage& left, Storage& right) {
    std::ranges::swap(left.value, right.value);
}
}

int main() {
    int a = 1, b = 2;
    std::ranges::swap(a, b);

    Library::Storage j{2}, k{3};
    std::ranges::swap(j, k); // calls custom Library::swap()
}
\end{cppcode}
\end{box-note}

Let’s finally talk about the other two variants, iter\_swap and swap\_ranges.

\cppversions{\texttt{iter\_swap}}{\CC98}{\CC20}{N/A}{\CC20}

Iter swap could also be called indirect swap, swapping the underlying values behind iterators or other indirect types. It is mainly helpful for implementing custom algorithms since those operate on iterators.

Here is an example of a partition algorithm implementation using iter\_swap (line 12):

\begin{box-note}
\begin{cppcode}
template <typename It, typename Cond>
    requires std::forward_iterator<It> 
        && std::indirectly_swappable<It,It> 
        && std::predicate<Cond>
auto partition(It first, It last, Cond cond) {
    while (first != last && cond(first)) ++first;
    if (first == last) return last;

    for (auto it = std::next(first); it != last; it++) {
        if (!cond(it)) continue;

        std::iter_swap(it, first);
        ++first;
    }
    return first;
}
\end{cppcode}
\end{box-note}

Swap ranges is a piecewise swap of two non-overlapping ranges (potentially from the same container). A begin iterator specifies the second range, and it is the caller’s responsibility to ensure that the target range has enough capacity.

\cppversions{\texttt{swap\_ranges}}{\CC98}{\CC20}{\CC17}{\CC20}

\begin{box-note}
\begin{cppcode}
std::vector<int> data{ 1, 2, 3, 4, 5, 6, 7, 8, 9};
std::swap_ranges(data.begin(), data.begin()+3, data.rbegin());
// 9, 8, 7, 4, 5, 6, 3, 2, 1
\end{cppcode}
\end{box-note}

Here we swap the first three elements of the array with the last three elements of the array. The order of elements is reversed because we use rbegin (begin iterator for reverse iteration).

\section{Sorting and partitioning algorithms}

\subsection{sort}

The basic sorting algorithm is unsurprisingly std::sort.

\cppversions{\texttt{sort}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints
    {\texttt{random\_access\_range}}
    {\texttt{random\_access\_range}}
    {N/A}
    {\texttt{strict\_weak\_ordering}}
    
While the actual implementation of std::sort might differ (usually intro-sort), it is guaranteed to be $O(n*logn)$ comparisons (since \CC11). As a result, it only operates on random-access ranges. This means that we can’t use std::sort with std::list, which does provide an $O(n*logn)$ sort as a method.

\begin{box-note}
\begin{cppcode}
{
    std::vector<int> data = {9, 1, 8, 2, 7, 3, 6, 4, 5};
    std::sort(data.begin(), data.end());
    // 1, 2, 3, 4, 5, 6, 7, 8, 9
}
{
    std::list<int> data = {9, 1, 8, 2, 7, 3, 6, 4, 5};
    //std::sort(data.begin(), data.end()); // doesn't compile
    data.sort();
    // 1, 2, 3, 4, 5, 6, 7, 8, 9
}
\end{cppcode}
\end{box-note}

With C++20, we can take advantage of projections to sort by a method or member:

\begin{box-note}
\begin{cppcode}
struct Account {
    double value();
};

std::vector<Account> fetch_accounts();

int main() {
    std::vector<Account> data = fetch_accounts();
    std::ranges::sort(data, std::greater<>(), &Account::value);
}
\end{cppcode}
\end{box-note}

Here we sort the accounts by their computed value in a descending (technically non-ascending) order. The std::greater<> is a C++14 specialization of std::greater that relies on type deduction to determine the parameter types. Before C++14, you would have to specify the type (in this case std::greater<double>()).

\subsubsection{Making your type comparable}

In the examples, we used std::sort on types that are inherently comparable in the base language or used a projection to narrow down the custom type to a double. However, sometimes you might want to make your custom type comparable.

First, let’s go back to the requirements of std::sort. It expects a strict\_weak\_ordering, which means that the comparison functor (or the less than operator) needs to be ireflexive: $\neg f(a,a)$, anti-symetric: $f(a,b) \Rightarrow \neg f(b,a) $, and transitive: $(f(a,b) \wedge f(b,c)) \Rightarrow f(a,c)$.

If you don’t have a domain-specific ordering for your particular data type, a solid default is lexicographical ordering. Lexicographical ordering is also the ordering provided by standard containers.

In C++20, implementing comparison for your type became a lot simpler with the introduction of the spaceship operator:

\begin{box-note}
\begin{cppcode}
struct Point {
    int x;
    int y;

    // pre-C++20 lexicographical less-than
    friend bool operator<(const Point& left, const Point& right) {
        if (left.x != right.x)
            return left.x < right.x;
        return left.y < right.y;
    }

    // default C++20 spaceship version of lexicographical comparison
    friend auto operator<=>(const Point&, const Point&) = default;

    // manual implementation of C++20 spaceship version of lexicographical comparison
    friend auto operator<=>(const Point& left, const Point& right) {
        if (left.x != right.x)
            return left.x <=> right.x;
        return left.y <=> right.y;
    }
};
\end{cppcode}
\end{box-note}

The default lexicographical ordering (line 13) works recursively. It starts with the object’s bases first, left-to-right, depth-first and then non-static members in declaration order (processing arrays element by element, left-to-right).

The type returned for the spaceship operator is the common comparison category type for the bases and members: strong\_ordering, weak\_ordering, or partial\_ordering.

\subsection{lexicographical\_compare, lexicographical\_compare\_three\_way}

When discussing lexicographical comparison, we have to talk about the two algorithms offering this functionality for ranges.

\cppversions{\texttt{lexicographical\_compare}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(input\_range, input\_range)}}{\texttt{(forward\_range, forward\_range)}}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

\begin{box-note}
\begin{cppcode}
std::vector<int> range1{1, 2, 3}, range2{1, 3}, range3{1, 3, 1};

assert(std::lexicographical_compare(range1.begin(), range1.end(), 
                                    range2.begin(), range2.end()));
assert(std::lexicographical_compare(range2.begin(), range2.end(), 
                                    range3.begin(), range3.end()));

assert(range1 < range2); // same as lexicographical_compare
assert(range2 < range3); // same as lexicographical_compare
\end{cppcode}
\end{box-note}

As I already mentioned, all standard containers offer lexicographical comparison through their comparison operators (before C++20) or the spaceship operator (since C++20). The primary use of manually calling lexicographical\_compare is when using C-style arrays or when you want to specify a custom element comparator:

\begin{box-note}
\begin{cppcode}
int x[] = {1, 2, 3}, y[] = {1, 4}; // for demonstration only, use std::array

assert(std::lexicographical_compare(&x[0], &x[3], &y[0], &y[2]));

std::vector<std::string> names1{"Zod", "Celeste"}, names2{"Adam", "Maria"};

assert(std::ranges::lexicographical_compare(names1, names2, 
        [](const std::string& left, const std::string& right) {
            return left.length() < right.length();
        }));
\end{cppcode}
\end{box-note}


The lexicographical\_compare\_three\_way is the spaceship operator equivalent to lexicographical\_compare. It returns one of strong\_ordering, weak\_ordering or partial\_ordering types (based on the provided functor).

\cppversions{\texttt{lexicographical\_compare\_three\_way}}{\CC20}{\CC20}{N/A}{N/A}

\constraints{\texttt{(input\_range, input\_range)}}{}{\texttt{operator<=>}}{\texttt{strong\_ordering}, \texttt{weak\_ordering}, \texttt{partial\_ordering}}

\subsection{stable\_sort}

The std::sort is free to re-arrange equivalent elements, which can be undesirable when re-sorting an already sorted range. The std::stable\_sort provides the additional guarantee of preserving the relative order of equal elements. If additional memory is available, stable\_sort remains $O(n*logn)$. However, if it fails to allocate, it will degrade to an $O(n*logn*logn)$ algorithm.

\cppversions{\texttt{stable\_sort}}{\CC98}{N/A}{\CC17}{\CC20}

\constraints{\texttt{random\_access\_range}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

While stable\_sort is not particularly useful when we are already sorting by every aspect of the type (e.g. by relying on lexicographical comparison), it often comes up when the sorting is based on user input (e.g. re-sorting by column in a UI).

\begin{box-note}
\begin{cppcode}
struct Record {
    std::string label;
    int rank;
};

std::vector<Record> data {{"q", 1}, {"f", 1}, {"c", 2}, {"a", 1}, {"d", 3}};

std::ranges::stable_sort(data, {}, &Record::label);    
std::ranges::stable_sort(data, {}, &Record::rank);
// Guarantted order: a-1, f-1, q-1, c-2, d-3
\end{cppcode}
\end{box-note}

\subsection{is\_sorted, is\_sorted\_until}

To verify whether a range is sorted according to the provided predicate, we can use is\_sorted. The default predicate is std::less.

\cppversions{\texttt{is\_sorted}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{std::less}}{\texttt{strict\_weak\_ordering}}

\begin{box-note}
\begin{cppcode}
std::vector<int> data1{1, 2, 3, 4, 5}, data2{5, 4, 3, 2, 1};

assert(std::is_sorted(data1.begin(), data1.end()));
assert(std::ranges::is_sorted(data2, std::greater<>()));
\end{cppcode}
\end{box-note}

Alternatively, we can use the is\_sorted\_until, which returns the iterator to the first out-of-order element.

\cppversions{\texttt{is\_sorted\_until}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{std::less}}{\texttt{strict\_weak\_ordering}}

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 5, 9, 2, 4, 6};
auto it = std::is_sorted_until(data.begin(), data.end());
// *it == 2
\end{cppcode}
\end{box-note}

\subsection{partial\_sort, partial\_sort\_copy}

Often, we are only interested in the top couple of elements in the sorted order, which is precisely what the partial sorting algorithms provide. The benefit of using a partial sort is faster runtime — approximately $O(n*logk)$, where k is the number of elements sorted.

\cppversions{\texttt{partial\_sort}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(random\_access\_range, random\_access\_iterator)}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

The sub-range to be sorted is specified using a middle iterator with the semantic [begin, middle) representing the sorted part of the range.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{9, 8, 7, 6, 5, 4, 3, 2, 1};
std::partial_sort(data.begin(), data.begin()+3, data.end());
// 1, 2, 3, -unspecified order-

std::ranges::partial_sort(data, data.begin()+3, std::greater<>());
// 9, 8, 7, -unspecified order-
\end{cppcode}
\end{box-note}

A variant of partial\_sort, advantageous when working with immutable source data, is partial\_sort\_copy.

\cppversions{\texttt{partial\_sort\_copy}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range -> random\_access\_range}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

This variant only requires the destination range to be mutable and random-access.

\begin{box-note}
\begin{cppcode}
struct ScoreRecord {
    std::string display;
    uint16_t score;
};

const std::vector<ScoreRecord>& get_records();

int main() {
    std::vector<ScoreRecord> top10(10, ScoreRecord{});
    std::ranges::partial_sort_copy(get_records(), top10, 
        std::greater<>(), &ScoreRecord::score, &ScoreRecord::score);
    // process top 10
}
\end{cppcode}
\end{box-note}

\subsection{partition, stable\_partition, partition\_copy, is\_partitioned}

Partition algorithms “partition” a range into two sub-ranges. First, all elements that satisfy the given predicate, followed by all elements that do not satisfy the predicate. Notably, a 3-way partition is the core building block of QuickSort.

\cppversions{\texttt{partition}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{N/A}{\texttt{unary\_predicate}}

If we are simply interested in grouping elements by a particular property, std::partition is the solution.

\begin{box-note}
\begin{cppcode}
struct ExamResult {
    std::string student_name;
    uint16_t score;
};

std::vector<ExamResult> get_results();

int main() {
    std::vector<ExamResult> results = get_results();
  
    auto pp = std::partition(results.begin(), results.end(), 
        [limit = 49](const ExamResult& result) {
            return result.score >= limit;
        });
 
    for (auto it = results.begin(); it != pp; it++) {
        // process students with passing mark
    }
    for (auto it = pp; it != results.end(); it++) {
        // process students with failing mark
     }
}
\end{cppcode}
\end{box-note}

Here we partition exam results into students that passed and failed. The partition algorithm returns the partition point (line 11). We can use the partition point to process the two parts of the range (lines 16 and 19).

Similarly to is\_sorted, we can check whether a range is partitioned (according to a given predicate) using is\_partitioned.

\cppversions{\texttt{is\_partitioned}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{N/A}{\texttt{unary\_predicate}}

\begin{box-note}
\begin{cppcode}
std::vector<int> data{2, 4, 6, 1, 3, 5};
auto is_even = [](int v) { return v % 2 == 0; };
assert(std::ranges::is_partitioned(data, is_even));
\end{cppcode}
\end{box-note}

Stable partition guarantees that it will not change the relative order of items.

\cppversions{\texttt{stable\_partition}}{\CC98}{N/A}{\CC17}{\CC20}

\constraints{\texttt{bidirectional\_range}}{}{N/A}{\texttt{unary\_predicate}}

\begin{box-note}
\begin{cppcode}
struct Item {
    std::string label;
    bool is_selected() const;
};

std::vector<Item> widget = get_widget();
std::ranges::stable_partition(widget, std::identity{}, &Item::is_selected);
// selected items moved to the beginning of the range
\end{cppcode}
\end{box-note}

This code might be confusing because we are using std::identity in place of the predicate. However, note that the result of the projection is a boolean value. Therefore, all we require from the predicate is to forward this value.

Finally, partition\_copy will not reorder the input range but instead copies the two partitions to the provided output ranges.

\cppversions{\texttt{partition\_copy}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range -> (output\_iterator, output\_iterator)}}{\texttt{forward\_range -> (forward\_iterator, forward\_iterator)}}{N/A}{\texttt{unary\_predicate}}

\begin{box-note}
\begin{cppcode}
std::vector<int> data{2, 4, 6, 1, 3, 5};
auto is_even = [](int v) { return v % 2 == 0; };

std::vector<int> even, odd;
std::partition_copy(data.begin(), data.end(),
    std::back_inserter(even),
    std::back_inserter(odd),
    is_even);

// even == {2, 4, 6}
// odd == {1, 3, 5}
\end{cppcode}
\end{box-note}

We are using the back\_inserter adapter to fill the two vectors without the need to pre-allocate enough capacity (the adapter internally calls push\_back).

\subsection{nth\_element}

Sometimes we only need to pick one specific element out of range (e.g. when choosing a median). Sorting (even partial) might then be overkill due to the $O(n*logn)$ complexity. For $O(n)$ complexity, we need to use a selection algorithm, and nth\_element is one of them.

\cppversions{\texttt{nth\_element}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(random\_access\_range, random\_access\_iterator)}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

The picked element is specified using a middle iterator. The algorithm will reorder the range so that this element will be in its sorted position. Moreover, the algorithm weakly partitions the range (every element before the middle is ≤ every element after the middle).

\begin{box-note}
\begin{cppcode}
std::vector<int> data{9, 1, 8, 2, 7, 3, 6, 4, 5};
std::nth_element(data.begin(), data.begin()+4, data.end());
// data[4] == 5

std::nth_element(data.begin(), data.begin()+7, data.end(), std::greater<>());
// data[7] == 2
\end{cppcode}
\end{box-note}

Depending on your use case, partial\_sort can be sometimes faster than nth\_element despite the worse theoretical complexity.

\subsection{C standard library: qsort}

Because the C standard library is part of the C++ standard library, we also have access to qsort.

\begin{box-note}
\begin{cppcode}
int data[] = {2, 1, 9, -1, 7, -8};
int size = sizeof data / sizeof(int);

qsort(data, size, sizeof(int), [](const void* left, const void* right){
    int vl = *(const int*)left;
    int vr = *(const int*)right;

    if (vl < vr) return -1;
    if (vl > vr) return 1;
    return 0;
});

// -8, -1, 1, 2, 7, 9
\end{cppcode}
\end{box-note}

I would strongly recommend avoiding qsort, as std::sort and std::ranges::sort should be a better choice in every situation. Moreover, qsort is only valid for trivially copyable types, and those will correctly optimize to memcpy operations even when using std::sort (if desirable).

\begin{box-note}
\begin{cppcode}
int data[] = {2, 1, 9, -1, 7, -8};
int size = sizeof data / sizeof(int);

std::sort(&data[0], &data[size], std::less<>());
// -8, -1, 1, 2, 7, 9
\end{cppcode}
\end{box-note}

\section{Algorithms that operate on sorted or partitioned ranges}

While hash-based containers give us the ability to look up any element in O(1) average time, this approach has two drawbacks. Firstly, we can only look up a specific element, and if that element is not present in the container, we get a simple lookup failure. Secondly, our type needs to be hashable.

Divide and conquer algorithms allow the lookup of bounds based on strict weak ordering and work even when the container’s specific value is not present. Additionally, since we are working with a sorted container, we can easily access neighbouring values once we have determined a boundary.

If you didn’t read previous chapter in the series, a strict weak ordering is an ordering that satisfies these constraints: is ireflexive: $\neg f(a,a)$, anti-symetric: $f(a,b) \Rightarrow \neg f(b,a)$, and transitive: $(f(a,b) \wedge f(b,c)) \Rightarrow f(a,c)$.

\subsection{lower\_bound, upper\_bound, equal\_range}

C++ offers three bound search algorithms.

\cppversions{\texttt{lower\_bound}}{\CC98}{\CC20}{N/A}{\CC20}
\cppversions{\texttt{upper\_bound}}{\CC98}{\CC20}{N/A}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

The algorithms differ in which bound they are searching for:

\begin{itemize}
    \item \texttt{lower\_bound} returns the first element that is not less than the provided value
    \item \texttt{upper\_bound} returns the first element that is greater than the provided value
\end{itemize}

If no such element exists, both algorithms return the end iterator.

\begin{box-note}
\begin{cppcode}
struct ExamResult {
    std::string student_name;
    uint16_t score;
};

const std::vector<ExamResult>& get_results();

int main() {
    const std::vector<ExamResult>& results = get_results();

    auto lb = std::ranges::lower_bound(results, 49, {}, &ExamResult::score);
    auto ub = std::ranges::upper_bound(results, 99, {}, &ExamResult::score);
 
    for (auto it = results.begin(); it != lb; it++) {
        // Process fails, upto 48
    }
    
    for (auto it = lb; it != ub; it++) {
        // Process passes, 49-99
    }
    
    for (auto it = ub; it != results.end(); it++) {
        // Process with honors, 100+
    }
}
\end{cppcode}
\end{box-note}

If you read the previous chapter, this piece of code might look familiar since we used std::partition for very similar behaviour. The main difference is that we are working with an immutable range (line 9) that we expect to be already in sorted order (in this case, for score). When we use both lower\_bound and upper\_bound, the resulting sub-range will represent the closed range of values, in this case [49,99] (lines 11, 12).

The logarithmic behaviour is only available for random-access ranges. Using lower\_bound or upper\_bound on std::set, std::multiset, std::map, or std::multimap will result in linear search.

Therefore, all these containers provided their $O(logn)$ implementations of lower and upper bound in the form of methods.

\begin{box-note}
\begin{cppcode}
std::multiset<int> data{1, 2, 3, 4, 5, 6, 6, 6, 7, 8, 9};

auto lb = data.lower_bound(6);
// std::distance(data.begin(), lb) == 5, *lb == 6

auto ub = data.upper_bound(6);
// std::distance(data.begin(), ub) == 8, *ub == 7
\end{cppcode}
\end{box-note}

A combination of lower\_bound and upper\_bound is equal\_range that returns both bounds.

\cppversions{\texttt{equal\_range}}{\CC98}{\CC20}{N/A}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

We could simulate equal\_range by calling both lower\_bound and upper\_bound for the same value.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 6, 6, 7, 8, 9};

auto [lb, ub] = std::equal_range(data.begin(), data.end(), 6);
// std::distance(data.begin(), lb) == 5, *lb == 6
// std::distance(data.begin(), ub) == 8, *ub == 7
\end{cppcode}
\end{box-note}

The bracket syntax (if you are not familiar with it) is structured bindings from C++17. Structured bindings allow us to decompose the std::pair returned by equal\_range into two named variables.

\subsection{partition\_point, binary\_search}

Despite the naming, partition\_point works very similarly to upper\_bound, however instead of searching for a particular value, it searches using a predicate.

\cppversions{\texttt{partition\_point}}{\CC11}{\CC20}{N/A}{\CC20}

\constraints{\texttt{forward\_range}}{}{N/A}{\texttt{unary\_predicate}}

Partition point will return the first element that does not satisfy the provided predicate. This algorithm only requires the range to be partitioned (with respect to the predicate).

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};
auto pp = std::partition_point(data.begin(), data.end(), 
                                [](int v) { return v < 5; });
// *pp == 5
\end{cppcode}
\end{box-note}

Finally, binary search serves as a presence check, returning boolean indicating whether the request value is present in the sorted range or not.

\cppversions{\texttt{binary\_search}}{\CC98}{\CC20}{N/A}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

While functionally identical to calling equal\_range and checking whether the returned range is empty, binary\_search will generally be faster. This is because the binary\_search algorithm must be implemented as a single search, while equal\_range is permitted two.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};

auto [lb, ub] = std::ranges::equal_range(data, 5);
bool exists = std::ranges::binary_search(data, 5);
assert((lb != ub) && exists);
\end{cppcode}
\end{box-note}

Since the number five is present in the range, equal\_range will return a non-empty range, and binary\_search will return TRUE.

\subsection{C standard library: bsearch}

From the C standard library, C++ inherits bsearch. This algorithm returns one of the elements equal to the provided key, or nullptr if none such element is found.

\begin{box-note}
\begin{cppcode}
int data[] = {-2, -1, 0, 1, 2};
int size = sizeof data / sizeof(int);

auto cmp = [](const void* left, const void* right){
    int vl = *(const int*)left;
    int vr = *(const int*)right;

    if (vl < vr) return -1;
    if (vl > vr) return 1;
    return 0;
};

int value = 1;
void* el1 = bsearch(&value, data, size, sizeof(int), cmp);
assert(*static_cast<int*>(el1) == 1);

value = 3;
void *el2 = bsearch(&value, data, size, sizeof(int), cmp); 
assert(el2 == nullptr);
\end{cppcode}
\end{box-note}

As with qsort, there is effectively no reason to use bsearch in C++ code.

Depending on the specific use case, one of the previously mentioned algorithms should be a suitable replacement.

\begin{box-note}
\begin{cppcode}
int data[] = {-2, -1, 0, 1, 2};
int size = sizeof data / sizeof(int);

int value = 1;
bool exist = std::binary_search(&data[0], &data[size], value);

auto candidate = std::lower_bound(&data[0], &data[size], value);
if (candidate != &data[size] && *candidate == value) {
    // process element
}

auto [lb, ub] = std::equal_range(&data[0], &data[size], value);
if (lb != ub) {
    // process equal elements
}
\end{cppcode}
\end{box-note}

\subsection{includes}

The first linear algorithm we will talk about is std::includes. This algorithm determines whether one range is a sub-range of another. Since we are working on sorted ranges, std::includes runs in linear time.

\cppversions{\texttt{includes}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(input\_range, input\_range)}}{\texttt{forward\_range, forward\_range)}}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

Here we check whether the input text contains all the lowercase English letters.

\begin{box-note}
\begin{cppcode}
std::vector<char> letters('z'-'a'+1,'\0');
std::iota(letters.begin(), letters.end(), 'a');

std::string input = "the quick brown fox jumps over the lazy dog";
std::ranges::sort(input);

assert(std::ranges::includes(input, letters));
\end{cppcode}
\end{box-note}

First, we generate the list of English letters programmatically using another algorithm std::iota (line 2). The iota algorithm generates consecutively increasing values to fill the given range. Because of this, we preallocate the vector to 26 elements (line 1).

\subsection{merge, inplace\_merge}

Another operation that is feasible in linear time is merging two sorted ranges.

\cppversions{\texttt{merge}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(input\_range, input\_range)}}{\texttt{(forward\_range, forward\_range)}}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

The result of the merge operation is stored using the provided output iterator. Note that the output range is not permitted to overlap with either of the input ranges.

The merge operation is stable. Equal elements from the first range will be ordered before equal elements from the second range.

\begin{box-note}
\begin{cppcode}
struct LabeledValue {
    int value;
    std::string label;
};

std::vector<LabeledValue> data1{{1, "first"}, {2, "first"}, {3, "first"}};
std::vector<LabeledValue> data2{{0, "second"}, {2, "second"}, {4, "second"}};

std::vector<LabeledValue> result;
std::ranges::merge(data1, data2, std::back_inserter(result),
  [](const auto& left, const auto& right) { return left.value < right.value; });
// result == {0, second}, {1, first}, {2, first}, {2, second}, {3, first}, {4, second}
\end{cppcode}
\end{box-note}

The parallel version requires the output to be a forward range (represented by a forward\_iterator). Therefore, we cannot use wrappers like std::back\_inserter and must preallocate the output range to sufficient capacity.

\begin{box-note}
\begin{cppcode}
std::vector<int> data1{1, 2, 3, 4, 5, 6};
std::vector<int> data2{3, 4, 5, 6, 7, 8};

std::vector<int> out(data1.size()+data2.size(), 0);
std::merge(std::execution::par_unseq,
    data1.begin(), data1.end(),
    data2.begin(), data2.end(),
    out.begin());
\end{cppcode}
\end{box-note}

\cppversions{\texttt{inplace\_merge}}{\CC98}{N/A}{\CC17}{\CC20}

\constraints{\texttt{(bidirectional\_range, bidirectional\_iterator)}}{}{\texttt{operator<}}{\texttt{inplace\_merge}}

Because merge forbids the input and output ranges from overlapping, we have an alternative inplace\_merge that serves this use case.

\begin{box-note}
\begin{cppcode}
std::vector<int> range{1, 3, 5, 2, 4, 6};
std::inplace_merge(range.begin(), range.begin()+3, range.end());
// range == { 1, 2, 3, 4, 5, 6 }
\end{cppcode}
\end{box-note}

\subsection{unique, unique\_copy}

The std::unique algorithm removes consecutive duplicate values. The typical use case is in conjunction with a sorted range. However, this is not a requirement of std::unique.

\cppversions{\texttt{unique}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

Because unique works in-place and cannot resize the underlying range, it leaves the end of the range with unspecified values and returns an iterator to the beginning of this sub-range (or the sub-range in case of the range version).

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 1, 2, 2, 3, 4, 5, 6, 6, 6};
auto it = std::unique(data.begin(), data.end());
// Range version: auto it = std::ranges::unique(data).begin();

// data == {1, 2, 3, 4, 5, 6, unspec, unspec, unspec, unspec}
data.resize(std::distance(data.begin(), it));
// data == {1, 2, 3, 4, 5, 6}
\end{cppcode}
\end{box-note}

\cppversions{\texttt{unique\_copy}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range -> output\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{\texttt{operator==}}{\texttt{binary\_predicate}}

The copy version of unique instead outputs the unique values to an output range represented by an iterator.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 1, 2, 2, 3, 4, 5, 6, 6, 6};
std::vector<int> out;
std::ranges::unique_copy(data, std::back_inserter(out));
// out == {1, 2, 3, 4, 5, 6}
\end{cppcode}
\end{box-note}

\subsection{set\_difference, set\_symmetric\_difference, set\_union, set\_intersection}

The last group of algorithms that require sorted ranges are set operations.

\cppversions{\texttt{set\_difference}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{set\_symmetric\_difference}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{set\_union}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{set\_intersection}}{\CC98}{\CC20}{\CC17}{\CC20}

All the set operations work in the same way, processing two input ranges and copying results into the result range, with the following semantics:

\begin{description}
   \item[\texttt{set\_difference}] elements that are present in the first range, but not the second
   \item[\texttt{set\_symmetric\_difference}] elements that are present in only one of the ranges, but not both
   \item[\texttt{set\_union}] elements that are present in either of the ranges
   \item[\texttt{set\_intersection}] elements that are present in both ranges
\end{description}

We also need to talk about the behaviour for equal elements. If we have m such elements in the first range and n such elements in the second range, the resulting range will contain:


\begin{description}
   \item[\texttt{set\_difference}] $max(m-n,0)$ elements
   \item[\texttt{set\_symmetric\_difference}] $abs(m-n)$, that is: if $m>n$, $m-n$ elements will be copied from the first range; otherwise, $n-m$ elements will be copied from the second range
   \item[\texttt{set\_union}] $max(m,n)$, first $m$ elements will be copied from the first range, followed by $max(n-m,0)$ elements from the second range
   \item[\texttt{set\_intersection}] $min(m,n)$, elements will be copied from the first range
\end{description}

\begin{box-note}
\begin{cppcode}
std::vector<int> data1{1, 2, 5};
std::vector<int> data2{2, 4, 6};

std::vector<int> difference;
std::ranges::set_difference(data1, data2, std::back_inserter(difference));
// difference == {1, 5}

std::vector<int> symmetric;
std::ranges::set_symmetric_difference(data1, data2, std::back_inserter(symmetric));
// symmetric == {1, 4, 5, 6}

std::vector<int> set_union;
std::ranges::set_union(data1, data2, std::back_inserter(set_union));
// set_union == {1, 2, 4, 5, 6}

std::vector<int> intersection;
std::ranges::set_intersection(data1, data2, std::back_inserter(intersection));
// intersection == {2}
\end{cppcode}
\end{box-note}

\section{Transformation algorithms}

\subsection{transform}

The most straightforward transformation possible is to apply a transformation function to each element.

\cppversions{\texttt{transform}}{\CC98}{\CC20}{\CC17}{\CC20}

% Mention lazy version

\constraints{\texttt{input\_range -> output\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{N/A}{\texttt{unary\_functor}}
\constraints{\texttt{(input\_range, input\_iterator) -> output\_iterator}}{\texttt{(forward\_range, forward\_iterator) -> forward\_iterator}}{N/A}{\texttt{binary\_functor}}

The standard library provides both a unary and a binary std::transform.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8};
std::transform(data.begin(), data.end(),
               data.begin(), [](int v) { return v*2; });
// data = {2, 4, 6, 8, 10, 12, 14, 16}

std::vector<int> add{8, 7, 6, 5, 4, 3, 2, 1};
std::transform(data.begin(), data.end(), add.begin(),
               data.begin(), [](int left, int right) {
                  return left+right; });
// data = {10, 11, 12, 13, 14, 15, 16, 17}
\end{cppcode}
\end{box-note}

Since the output range is specified using an iterator, both transform algorithms can operate inline or output to another range.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8};
std::vector<int> out;
std::transform(data.begin(), data.end(),
    std::back_inserter(out), [](int v) { return v*2; });
// out = {2, 4, 6, 8, 10, 12, 14, 16}
\end{cppcode}
\end{box-note}

For both variants, the provided functor cannot invalidate iterators or modify elements of either of the ranges. On top of that, neither transform guarantees that the provided functor will be applied strictly left-to-right (which only matters for stateful functors).

These limitations are what sets the unary std::transform apart from std::for\_each.

\begin{box-note}
\begin{cppcode}
struct MyStruct {
    void some_modifying_operation() {}
};

std::vector<int> data(8, 1);
std::ranges::for_each(data, [v = 0](int& el) mutable { el = ++v; });
// data = {1, 2, 3, 4, 5, 6, 7, 8}

// Unspecified result:
std::ranges::transform(data, data.begin(), [v = 0](int) mutable { return ++v; });

std::vector<MyStruct> db{{}, {}, {}};
std::ranges::for_each(db, [](auto& el) { el.some_modifying_operation(); });

// INVALID:
std::ranges::transform(db, db.begin(), 
    [](MyStruct& el) -> MyStruct& { el.some_modifying_operation(); return el; });
// Valid, operating on a copy:
std::ranges::transform(db, db.begin(), 
    [](MyStruct el) -> MyStruct { el.some_modifying_operation(); return el; });
\end{cppcode}
\end{box-note}

The example utilizes mutable lambdas (lines 6 and 10) and generalized lambda capture from C++14 that allows the creation and initialization of variables in the capture section of the lambda.

Transform is also the first algorithm we talked about with a lazy variant. C++20 introduced the concept of views as part of the ranges functionality.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7};
auto is_even = [](int v) { return v % 2 == 0; };

std::vector<int> out;
auto even_squares = data
             | std::ranges::views::filter(is_even) 
             | std::ranges::views::transform([](int v) { return v*v; });

std::ranges::copy(even_squares, std::back_inserter(out));
// out = {4, 16, 36}
\end{cppcode}
\end{box-note}

I have a separate article on C++20 ranges that also covers Views. The main takeaways here are:

\begin{itemize}
    \item composing views happens at compile-time; there is no runtime operation happening on line 5
    \item the even\_squares object is a view itself; it is cheap to copy and move and doesn’t own the data it is viewing
    \item each component of the view is evaluated lazily; if we read only a single element out of the even\_squares view, the views::filter would be evaluated twice and views::transform only once
\end{itemize}

\subsection{adjacent\_difference}

Despite the naming, adjacent\_difference is a variant of a binary transform, operating on adjacent elements in a single range.

Unlike transform, adjacent\_difference guarantees left-to-right application. Furthermore, because input ranges permit each element to be read only once, the algorithm internally stores a copy of the last read value (for use as the left operand).

\cppversions{\texttt{adjacent\_difference}}{\CC98}{\CC20}{\CC17}{N/A}

\constraints{\texttt{input\_range -> output\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{\texttt{operator -}}{\texttt{binary\_functor}}

The default version will calculate the difference of adjacent elements, with the first element copied.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{2, 4, 8, 16, 32, 64};
std::adjacent_difference(data.begin(), data.end(), data.begin());
// 2, 2 (4-2), 4 (8-4), 8 (16-8), 16 (32-16), 32 (64-32)
\end{cppcode}
\end{box-note}

However, since we can choose a different functor (other than std::minus), we can also use std::adjacent\_difference to generate sequences:

\begin{box-note}
\begin{cppcode}
std::vector<int> data(10, 1);
std::adjacent_difference(data.begin(), std::prev(data.end()), 
                         std::next(data.begin()), std::plus<int>());
// Fibonacci sequence: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,
\end{cppcode}
\end{box-note}

Note that the std::next(data.begin()) for the output range is critical here. The adjacent\_difference algorithm will read each element only once and remembers the previously read value for the left argument. The std::next ensures that we generate one element ahead of either argument.

\subsection{remove, remove\_if}

\cppversions{\texttt{remove, remove\_if}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{N/A}{\texttt{unary\_predicate}}

Similar to std::unique, the algorithm cannot resize the range, so it instead returns an iterator to designate the new end.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5};
auto it = std::remove(data.begin(), data.end(), 3);
data.resize(it-data.begin()); // Random Access Ranges only
// data = {1, 2, 4, 5}

auto is_even = [](int v) { return v % 2 == 0; };
it = std::remove_if(data.begin(), data.end(), is_even);
data.erase(it, data.end()); // Erase sub-range
// data = {1, 5}
\end{cppcode}
\end{box-note}

This naming schema will be repeated across several algorithms. The base version is always a variant that operates based on a provided value (line 2), the \_if variant relies on a provided predicate (line 7).

While remove doesn’t have a direct lazy version, we can often replace it with std::views::filter.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5};
auto is_odd = [](int v) { return v % 2 != 0; };
for (int v : data | std::ranges::views::filter(is_odd)) {
    // iterate over 1, 3, 5
}
\end{cppcode}
\end{box-note}

A significant difference is that views::filter changes how the range is iterated and does not modify its actual content of the range.

\subsection{replace, replace\_if}

We can use the replace algorithm to replace values instead of removing them.

\cppversions{\texttt{replace, replace\_if}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{N/A}{\texttt{unary\_predicate}}

Following the same naming schema, std::replace replaces elements matching a given value, whereas std::replace\_if replaces elements based on a predicate.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7};
std::ranges::replace(data, 4, 0);
// data={1, 2, 3, 0, 5, 6, 7}

auto is_odd = [](int v) { return v % 2 != 0; };
std::ranges::replace_if(data, is_odd, -1);
// data={-1, 2, -1, 0, -1, 6, -1}
\end{cppcode}
\end{box-note}

\subsection{reverse, rotate, shuffle}

The reverse algorithm provides a straightforward swap-based reversion of a given bi-directional range.

\cppversions{\texttt{reverse}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{bidirectional\_range}}{}{}{}

While only C++20 introduced the view version of reverse, every bidirectional range natively supports reverse iteration through the rbegin() and rend() variants of begin() and end() iterators.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7};
std::reverse(data.begin(), data.end());
// data = {7, 6, 5, 4, 3, 2, 1}

for (auto it = data.rbegin(); it != data.rend(); ++it) {
    // iterate over: 1, 2, 3, 4, 5, 6, 7
}

for (auto v : data | std::views::reverse) {
    // iterate over: 1, 2, 3, 4, 5, 6, 7
}
\end{cppcode}
\end{box-note}

When working with legacy types such as C arrays or strings, reverse iteration can be awkward. However, we can lean on std::span (since C++20) and std::string\_view (since C++17) that both provide bi-directional support.

\begin{box-note}
\begin{cppcode}
int c_array[] = {1, 2, 3, 4, 5, 6, 7};
auto arr_view = std::span(c_array, sizeof(c_array)/sizeof(int));

for (auto it = arr_view.rbegin(); it != arr_view.rend(); ++it) {
    // iterate over: {7, 6, 5, 4, 3, 2, 1}
}

const char* c_string = "No lemon, no melon";
auto str_view = std::string_view(c_string);

for (auto it = str_view.rbegin(); it != str_view.rend(); ++it) {
    // iterate over: "nolem on ,nomel oN"
}
\end{cppcode}
\end{box-note}

The reverse algorithm also gives us an excellent place to demonstrate a more advanced composition of views. For example, the following is a trim view that skips over leading and trailing whitespace:

\begin{box-note}
\begin{cppcode}
const char* c_string = "  No lemon, no melon.     ";
auto str_view = std::string_view(c_string);

auto is_ws = [](char c) { return isspace(c); };
auto skip_ws = std::views::drop_while(is_ws);
auto skip_trailing_ws = std::views::reverse | skip_ws | std::views::reverse;
auto trim = skip_trailing_ws | skip_ws;

std::string out;
std::ranges::copy(str_view | trim, std::back_inserter(out));
// out = "No lemon, no melon."
\end{cppcode}
\end{box-note}

As with previous examples, no runtime computation is happening on lines 4–7, and the processing is done on-demand as the std::copy algorithm iterates over the composed view (line 10).

We start with a predicate that returns true for whitespace characters (line 4). We then utilize the drop\_while view that skips over elements until the predicate returns false (line 5). This is already our one-way trim.

To construct a reverse trim, we reverse the range, trim the now leading whitespace and then reverse the range again (line 6). Finally, the full trim is simply a composition of the two partial trim operations.

The rotate algorithm does precisely that, and it rotates the elements in the range such that the designated element is now the first element of the range.

\cppversions{\texttt{rotate}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(forward\_range, forward\_iterator)}}{}{}{}

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7};
std::rotate(data.begin(), data.begin()+3, data.end());
// data=4, 5, 6, 7, 1, 2, 3
\end{cppcode}
\end{box-note}

The shuffle algorithm is a successor of the now-defunct random\_shuffle algorithm (deprecated in C++14, removed in C++17) and relies on new random facilities added in C++11.

\cppversions{\texttt{shuffle}}{\CC11}{N/A}{N/A}{\CC20}

\constraints{\texttt{random\_access\_range}}{}{}{}

The random facilities are out of scope for this article. However, shuffle will work with any uniform random bit generator.

\begin{box-note}
\begin{cppcode}
struct Card {
    unsigned index;
    
    friend std::ostream& operator << (std::ostream& s, const Card& card) {
        static constexpr std::array<const char*, 13> ranks = {"Ace", "Two", "Three", 
          "Four", "Five", "Six", "Seven", "Eight", 
          "Nine", "Ten", "Jack", "Queen", "King"};
        static constexpr std::array<const char*, 4> suits = {"Hearts", "Diamonds", 
                                                             "Clubs", "Spades"};

        if (card.index >= 52)
            throw std::domain_error("Card index has to be in the range 0..51");

        s << ranks[card.index%13] << " of " << suits[card.index/13];

        return s;
    }
};

std::vector<Card> deck(52, Card{});
std::ranges::generate(deck, [i = 0u]() mutable { return Card{i++}; });
// deck = {Ace of Hearts, Two of Hearts, Three of Hearts, Four of Hearts...}

std::random_device rd;
std::mt19937 gen{rd()};

std::ranges::shuffle(deck, gen);
// deck = { random order }
\end{cppcode}
\end{box-note}

We use the std::generate algorithm, which we will discuss in an upcoming article, to generate the 52 unique cards (line 21). After generating, the cards will be in sorted order.

We then use the Mersenne Twister Engine uniform bit generator (in its 32bit pre-defined alias), which we pass to the shuffle algorithm resulting in a randomly shuffled range.

The output stream operator overload on lines 4–17 provides the translation from index to a text representation, e.g. “Jack of Clubs”.

\subsection{next\_permutation, prev\_permutation, is\_permutation}

Permutation algorithms will generate either the next or previous permutation in lexicographical order.

\cppversions{\texttt{next\_permutation, prev\_permutation}}{\CC98}{\CC20}{N/A}{\CC20}

\constraints{\texttt{bidirectional\_range}}{}{\texttt{operator <}}{\texttt{strict\_weak\_ordering}}

Strictly speaking, calling next\_permutation will adjust the order of elements such that it is the next higher value as per std::lexicographical\_compare (using the same functor). If there is no such range, next\_permutation will cycle back to the lowest value and return false.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3};
do {
    // iterate over:
    // 1, 2, 3
    // 1, 3, 2
    // 2, 1, 3
    // 2, 3, 1
    // 3, 1, 2
    // 3, 2, 1
} while (std::next_permutation(data.begin(), data.end()));
// data = {1, 2, 3}
\end{cppcode}
\end{box-note}

When used with a range of booleans, next\_permutation can serve to iterate over all sets of a particular size.

\begin{box-note}
\begin{cppcode}
std::vector<std::string> data{"apple", "avocado", "banana", 
  "cherry", "lemon", "mango", 
  "orange", "plums", "watermelon"};

std::vector<char> pick(data.size(), false);
std::fill_n(pick.begin(), 3, true);

do {
    for (size_t i = 0; i < pick.size(); ++i) {
        if (pick[i])
            std::cout << data[i] << ", ";
    }
    std::cout << "\n";
} while (std::prev_permutation(pick.begin(), pick.end(), std::less<bool>()));
\end{cppcode}
\end{box-note}

We start with a range filled with false values, setting the first three elements to true (line 6). We then print out the elements corresponding to the TRUE values (line 10). Finally, prev\_permutation will return false once we have cycled back to the initial range with the first three elements set to true (line 14).

Lastly, to check whether one range is a permutation of another, we can use the is\_permutation algorithm.

\cppversions{\texttt{is\_permutation}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(forward\_range, forward\_range)}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

The utility of is\_permutation mainly pops up in testing, where we often need to test whether two ranges are piecewise equal but not necessarily in the same order.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 8, 1, 7, 3, 4, 6, 2, 5};
for (size_t i = 0; i < data.size()-1; ++i)
    for (size_t j = i+1; j < data.size(); ++j)
        if (data[i] > data[j])
            std::swap(data[i], data[j]);

assert(std::ranges::is_sorted(data));
assert(std::ranges::is_permutation(data, 
                                   std::vector<int>{1, 2, 3, 4, 5, 6, 7, 8}));
\end{cppcode}
\end{box-note}

\section{Left folds and other reductions}

All algorithms we will discuss today (except for the boolean reductions) come from the <numeric> header and do not have counterparts in the C++20 ranges library (some support to land in C++23).

\subsection{accumulate, inner\_product}

We start with the left folds, algorithms that operate strictly left to right, evaluating accumulator = op(accumulator, element) for each element and returning the final accumulator value.

\cppversions{\texttt{accumulate}}{\CC98}{\CC20}{N/A}{N/A}

\constraints{\texttt{input\_range}}{}{\texttt{operator +}}{\texttt{binary\_functor}}

Due to the strictly linear operation, we do not have access to parallel versions of these algorithms. The default version of accumulate uses the binary operator+, and if specified, the binary functor is not permitted to modify the elements in the range or invalidate iterators.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5};
auto sum = std::accumulate(data.begin(), data.end(), 0);
// sum == 15
auto product = std::accumulate(data.begin(), data.end(), 1, std::multiplies<>{});
// product == 120
\end{cppcode}
\end{box-note}

To turn any of the left fold algorithms into a right fold, we can use rbegin() and rend() (as long as the range is bidirectional).

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5};
auto left = std::accumulate(data.begin(), data.end(), 0, [](int acc, int el) {
    return acc / 2 + el;
});
auto right = std::accumulate(data.rbegin(), data.rend(), 0, [](int acc, int el) {
    return acc / 2 + el;
});
// left == 8, right == 3
\end{cppcode}
\end{box-note}

By adding another range and a join operation, we arrive at inner\_product. The left fold operation changes to accumulator = op(accumulator, join(elem1, elem2)), where elem1 comes from the first range and elem2 from the second range.

\cppversions{\texttt{inner\_product}}{\CC98}{\CC20}{N/A}{N/A}

\constraints{\texttt{(input\_range, input\_iterator)}}{}{\texttt{operator *, operator +}}{\texttt{(binary\_functor, binary\_functor)}}

The default version uses operator+ for the accumulation and operator* for the join. If specified, neither functor is permitted to modify the elements or invalidate iterators.

\begin{box-note}
\begin{cppcode}
std::vector<int> heights{1, 2, 3, 4, 5};
std::vector<int> widths{2, 3, 4, 5, 6};
auto total_area = std::inner_product(heights.begin(), heights.end(), widths.begin(), 0);
// total_area == 70
\end{cppcode}
\end{box-note}

Naturally, we can also use inner\_product with a single range, for example, to calculate the sum of absolute differences between consecutive elements:

\begin{box-note}
\begin{cppcode}
std::vector<int> data{6, 4, 3, 7, 2, 1};
auto sum_of_diffs = std::inner_product(data.begin(), std::prev(data.end()), 
                                       std::next(data.begin()), 
                                       0, std::plus<>{}, 
                                       [](int left, int right) { return std::abs(left-right); });
// sum_of_diffs == 13
\end{cppcode}
\end{box-note}

\subsection{A short arithmetic detour}

The algorithms in the <numeric> header can have sharp edges. This mainly has to do with the way C++ handles mixed numerical types and how template deduction works. For example, the following is an easy mistake to make:

\begin{box-note}
\begin{cppcode}
std::vector<double> data{1.1, 2.2, 3.3, 4.4, 5.5};
auto result = std::accumulate(data.begin(), data.end(), 0);
// result == 15 (actual sum 16.5)
\end{cppcode}
\end{box-note}

Because we are passing a 0 as the initial value of the accumulator, which is a constant of type int, the accumulator ends up as int. Each fold operation then adds an integer and a double, resulting in a floating-point value. However, it immediately stores it in an integer variable, truncating the value.

If you want to avoid this problem, you need to be familiar with literal suffixes:

% TODO: include this information directly in the book, instead of the original links.
\begin{itemize}
    \item integer literal suffixes
    \item floating-point literal suffixes
    \item fixed-size integer literal macros
\end{itemize}

The second problem arises when mixing different integer types, particularly signed and unsigned integers. Again, as long as you do not mix types, you will not run into issues, but remember that the types that matter are the element types, the initial accumulator value and the functor arguments and return type.

\begin{box-note}
\begin{cppcode}
std::vector<unsigned> data{1, std::numeric_limits<unsigned>::max()/2};
auto ok = std::accumulate(data.begin(), data.end(), 0u, 
                          [](auto acc, auto el) { return acc + el; });
// Always OK, matching types.

auto impl = std::accumulate(data.begin(), data.end(), 0, 
                            [](auto acc, auto el) { return acc + el; });
// Implementation defined:
// acc is int
// in acc + el: acc promoted to unsigned, result is unsigned

// if an unsigned value cannot be represented by the target singed variable
// the behavior is implementation defined

auto maybe = std::accumulate(data.begin(), data.end(), 0L, 
                             [](auto acc, auto el) { return acc + el; });
// OK as long as sizeof(long) > sizeof(unsigned)
// acc is long
// in acc + el: el is promoted to long

// if sizeof(long) > sizeof(unsigned), the long can represent all 
// values of unsigned, therefore OK
\end{cppcode}
\end{box-note}

These are arguably very synthetic examples and shouldn’t appear in production codebases.

If you are interested in more details about integer conversions and promotions, there is an excellent cheatsheet from hackingcpp on this topic.

\subsection{partial\_sum}

The partial\_sum algorithm is a bit of an outlier here, as it’s not a strict reduction algorithm. Instead, it computes partial sums on the given range. The nth generated element is the sum of the first n elements from the source range.

\cppversions{\texttt{partial\_sum}}{\CC98}{\CC20}{N/A}{N/A}

\constraints{\texttt{input\_range -> output\_iterator}}{}{\texttt{operator+}}{\texttt{binary\_functor}}

The output iterator is permitted to be the input ranges’ begin iterator. The default operation is the binary plus, and a custom functor is not permitted to modify elements or invalidate iterators.

\begin{box-note}
\begin{cppcode}
std::vector<int> data(6, 1);
// data == {1, 1, 1, 1, 1, 1}
std::partial_sum(data.begin(), data.end(), data.begin());
// data == {1, 2, 3, 4, 5, 6}

std::vector<int> out;
std::partial_sum(data.begin(), data.end(), std::back_inserter(out), std::multiplies<>{});
// out == {1, 2, 6, 24, 120, 720}
\end{cppcode}
\end{box-note}

\subsection{reduce, transform\_reduce}

The previous algorithms we talked about are all left folds. They evaluate strictly linearly from left to right, which removes any potential for parallel execution.

However, when we work with operations that are associative op(a, op(b,c)) == op(op(a,b),c) and commutative op(a,b) == op(b,a), it really doesn’t matter what permutation of elements and order of operations we evaluate, we will always arrive at the same result.

In C++17, along with the other parallel algorithms, we have received reduce, inclusive\_scan and exclusive\_scan, which are relaxed versions of accumulate, inner\_product and partial\_sum that require an associative and commutative operation to produce deterministic results.

\cppversions{\texttt{reduce}}{\CC17}{\CC20}{\CC17}{N/A}

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{\texttt{std::plus<>()}}{\texttt{binary\_functor}}

On top of the accumulate equivalents, we get one more overload that does away with the initial accumulator value, reducing the aforementioned numerical problems.

\begin{box-note}
\begin{cppcode}
std::vector<double> data{1.1, 2.2, 3.3, 4.4, 5.5};
auto result = reduce(data.begin(), data.end());
// result == 16.5
\end{cppcode}
\end{box-note}

The accumulator will be of the type of the ranges’ elements and will be value initialised. So, the accumulator will be type double and initialised to zero in this example.

Of course, this also works for custom types:

\begin{box-note}
\begin{cppcode}
struct Duck {
    std::string sound = "Quack";
    friend Duck operator+(const Duck& left, const Duck& right) {
        return {left.sound+right.sound};
    }
};

std::vector<Duck> data(2, Duck{});
Duck final_duck = std::reduce(data.begin(), data.end());
// final_duck.sound == "QuackQuackQuack"
\end{cppcode}
\end{box-note}

The initial value of the accumulator will be “Quack”. Adding the other two ducks, we end up with “QuackQuackQuack”.

The counterpart to inner\_product is transform\_reduce, with additional overloads for the unary case (single range).

\cppversions{\texttt{transform\_reduce}}{\CC17}{\CC20}{\CC17}{N/A}

Unary version:

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{N/A}{\texttt{(binary\_functor, unary\_functor)}}

Binary version:

\constraints{\texttt{(input\_range, input\_iterator)}}{\texttt{(forward\_range, forward\_iterator)}}{\texttt{(std::plus<>(), std::multiplies<>())}}{\texttt{(binary\_functor, binary\_functor)}}

Same as reduce, provided functors must not modify the elements or invalidate iterators. In addition, the reduction functor must be associative and commutative.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5};
auto sum_of_squares = std::transform_reduce(data.begin(), data.end(), 0, 
                                            std::plus<>{}, [](int v) { return v*v; });
// sum_of_squares == 55

std::vector<int> coef{1, -1, 1, -1, 1};
auto result = std::transform_reduce(data.begin(), data.end(), coef.begin(), 0);
// result == 1*1 + 2*(-1) + 3*1 + 4*(-1) + 5*1 == 3
\end{cppcode}
\end{box-note}

\subsection{exclusive\_scan, inclusive\_scan, transform\_exclusive\_scan, transform\_inclusive\_scan}

The last left-fold algorithm without a parallel counterpoint is partial\_sum.

\cppversions{\texttt{exclusive\_scan, inclusive\_scan}}{\CC17}{\CC20}{\CC17}{N/A}

\constraints{\texttt{input\_range -> output\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{\texttt{std::plus<>()}}{\texttt{binary\_functor}}

The 1:1 counterpoint to partial\_sum is inclusive\_scan, which follows the same logic: nth generated element is the sum of the first n source elements. On top of that, we also get exclusive\_scan, where the nth generated element is the sum of the first n-1 source elements. Or: the inclusive version includes the element on the nth position, and the exclusive version excludes it.

Consequently, for the exclusive\_scan algorithm, we must specify an initial value of the accumulator, which will be the value of the first generated element.

\begin{box-note}
\begin{cppcode}
std::vector<int> src{1, 2, 3, 4, 5, 6};
{
    std::vector<int> out;
    std::inclusive_scan(src.begin(), src.end(), std::back_inserter(out));
    // out == {1, 3, 6, 10, 15, 21}
    std::inclusive_scan(src.begin(), src.end(), out.begin(), std::multiplies<>{}, 1);
    // out == {1, 2, 6, 24, 120, 720}
}
{
    std::vector<int> out;
    std::exclusive_scan(src.begin(), src.end(), std::back_inserter(out), 0);
    // out == {0, 1, 3, 6, 10, 15}
    std::exclusive_scan(src.begin(), src.end(), out.begin(), 1, std::multiplies<>{});
    // out == {1, 1, 2, 6, 24, 120}
}
\end{cppcode}
\end{box-note}

\cppversions{\texttt{transform\_inclusive\_scan, transform\_exclusive\_scan}}{\CC17}{\CC20}{\CC17}{N/A}

\constraints{\texttt{input\_range -> output\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{N/A}{\texttt{(binary\_functor, unary\_functor)}}

The transform variants of inclusive\_scan and exclusive\_scan apply a unary transformation to each element. Unfortunately, we do not get an overload that would operate on two input ranges (in the style of inner\_product).

\begin{box-note}
\begin{cppcode}
std::vector<int> data{-10, 3, -2, 5, 6};

std::vector<int> out1;
std::inclusive_scan(data.begin(), data.end(), std::back_inserter(out1), 
                    std::plus<>{});
// out1 == {-10, -7, -9, -4, 2}

std::vector<int> out2;
std::transform_inclusive_scan(data.begin(), data.end(), std::back_inserter(out2), 
                              std::plus<>{}, [](int v) { return std::abs(v); });
// out2 == {10, 13, 15, 20, 26}
\end{cppcode}
\end{box-note}

\subsection{all\_of, any\_of, none\_of}

Finally, we switch back to the <algorithm> header, where we have three boolean reductions.

\cppversions{\texttt{all\_of, any\_of, none\_of}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{N/A}{\texttt{unary\_predicate}}

The algorithms follow the expected boolean logic.

\begin{tabular}{c c c c c}
\hline
& all true & all false & mixed & empty \\
\hline
\texttt{all\_of} & true & false & false & true \\
\hline
\texttt{any\_of} & true & false & true & false \\
\hline
\texttt{none\_of} & false & true & false & true \\
\hline
\end{tabular}

Note that any\_of requires a positive presence; it only returns true if there is at least one element for which the predicate returns true and returns false on an empty range.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{-2, 0, 2, 4, 6, 8};
auto is_even = [](int v) { return v % 2 == 0; };
auto is_odd = [](int v) { return v % 2 != 0; };
auto is_negative = [](int v) { return std::signbit(v); };

assert(std::ranges::all_of(data, is_even));
assert(std::ranges::any_of(data, is_negative));
assert(std::ranges::none_of(data, is_odd));
\end{cppcode}
\end{box-note}

\section{Generators, copies and moves}

We will start with the prototypical generator algorithm that generates consecutive values.

\subsection{iota}

Iota is an outlier when it comes to C++20 std::ranges support. C++20 introduced the lazy view version std::views::iota, and we will only get the eager range version of the algorithm in C++23.

\cppversions{\texttt{iota}}{\CC11}{\CC20}{N/A}{\CC23}

\constraints{\texttt{forward\_range}}{}{}{}

The std::iota algorithm will generate elements by consecutively applying the prefix increment operator, starting with the initial value.

\begin{box-note}
\begin{cppcode}
std::vector<int> data(11, 0);

std::iota(data.begin(), data.end(), -5); 
// data == { -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5 }

std::vector<int> out;
std::ranges::transform(std::views::iota(1, 10), std::views::iota(5), 
                       std::back_inserter(out), std::plus<>{});
// out == { 6, 8, 10, 12, 14, 16, 18, 20, 22 }
\end{cppcode}
\end{box-note}

Here we take advantage of the finite view constructor std::views::iota(1,10) to establish the output size (line 7), which allows us to use the infinite view std::views::iota(5) for the second parameter. Functionally, we could swap even the second view for a finite one. However, this would impose an additional (and unnecessary) boundary check.

\subsection{fill, fill\_n, generate, generate\_n}

\cppversions{\texttt{fill, generate}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{}{}

The std::fill algorithm fills the designated range with the provided value, and std::generate fills the designated range with values resulting from successive invocations of the provided invocable.

\begin{box-note}
\begin{cppcode}
std::vector<int> data(5, 0);
std::fill(data.begin(), data.end(), 11);
// data == (11, 11, 11, 11, 11)

std::ranges::generate(data, []() { return 5; });
// data == (5, 5, 5, 5, 5)

// iota-like
std::ranges::generate(data, [i = 0]() mutable { return i++; });
// data == (0, 1, 2, 3, 4)
\end{cppcode}
\end{box-note}

The iota-like behaviour (line 9) is possible because the standard guarantees successive (left-to-right) invocations of the provided invocable.

When working with ranges that do not support random access, it might be slow or impossible to provide the end of the range iterator. The standard offers variants of fill and generate where the range is specified using a begin iterator and the number of elements to cover this case.

\cppversions{\texttt{fill\_n, generate\_n}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{output\_iterator}}{\texttt{forward\_iterator}}{}{}

Other than the change in how a range is specified, these variants have identical behaviour to the baseline algorithms.

\begin{box-note}
\begin{cppcode}
std::vector<int> data;
std::fill_n(std::back_inserter(data), 5, 11);
// data == (11, 11, 11, 11, 11)

data.clear();
std::ranges::generate_n(std::back_inserter(data), 5, []() { return 5; });
// data == (5, 5, 5, 5, 5)
\end{cppcode}
\end{box-note}

\subsection{Iterator adapaters}

We have already used the std::back\_inserter many times across the examples in this series, so let's start with inserter adapters.

\subsubsection{back\_inserter, front\_inserter, inserter}

The standard offers three adapters that create instances of back\_insert\_iterator, front\_insert\_iterator and insert\_iterator. When assigned to, these iterators call the corresponding push\_back, push\_front and insert methods on the adapted container.

\begin{box-note}
\begin{cppcode}
std::list<int> data;
auto back = std::back_inserter(data);
auto front = std::front_inserter(data);

*back = 10;
// data == { 10 }
*front = 20;
// data == { 20, 10 }

auto mid = std::inserter(data, std::next(data.begin()));
*mid = 5;
// data == { 20, 5, 10 }
\end{cppcode}
\end{box-note}

All inserter iterators model only output iterator concept, therefore cannot be used with algorithms that require forward or bidirectional iterators.

\subsubsection{istream\_iterator, ostream\_iterator}

These two adapters provide iteration over istream and ostream, respectively.

The istream\_iterator will read a value by calling the corresponding operator>> when incremented.

\begin{box-note}
\begin{cppcode}
std::stringstream input("10 20 30 40 50");
auto in = std::istream_iterator<int>(input);

int i = *in; // i == 10
++in;
int j = *in; // j == 20
\end{cppcode}
\end{box-note}

The ostream\_iterator will write a value by calling the corresponding operator<< when assigned to.

\begin{box-note}
\begin{cppcode}
std::stringstream output;
auto out = std::ostream_iterator<int>(output, ", ");

*out = 10;
*out = 20;
// output == "10, 20,"
\end{cppcode}
\end{box-note}

The additional parameter for ostream\_iterator specifies the divider added after each element.

The istream\_iterator models an input iterator, and the ostream\_iterator models an output iterator.

\subsubsection{move\_iterator, make\_move\_iterator}

The move\_iterator adapter inherits the iterator category from the adapted iterator but will return an rvalue when dereferenced, thus enabling move semantics.

\begin{box-note}
\begin{cppcode}
std::vector<std::string> data = { "a", "b", "c" };
auto it = std::make_move_iterator(data.begin());

std::string str(*it); // move construction
++it;
str = *it; // move assignment
// data == { ?, ?, "c" }
// str == "b"
\end{cppcode}
\end{box-note}

\subsubsection{reverse\_iterator}

We can use the reverse\_iterator adapter for bidirectional iterators to obtain the iterator for the opposite direction.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 1, 2, 3 };
auto mid = std::reverse_iterator(data.end());

int i = *mid; // i == 3
++mid;
int j = *mid; // j == 2
\end{cppcode}
\end{box-note}

Note that the reversed iterator maps to the previous element in the source direction. Therefore, when reversing begin or rbegin, the result is rend and end, respectively.

\subsubsection{counted\_iterator}

When working with non-random-access ranges, it is convenient to specify the range using a begin iterator coupled with the number of elements. The counted\_iterator brings this feature to C++20 ranges without the need for specialised algorithm variants like std::fill\_n.

\begin{box-note}
\begin{cppcode}
std::list<int> data = { 1, 2, 3, 4, 5 };

std::ranges::fill(std::counted_iterator(data.begin(), 3), std::default_sentinel, 9);
// data == { 9, 9, 9, 4, 5 }
\end{cppcode}
\end{box-note}

The counted\_iterator keeps track of the number of elements, and when the counter reaches zero, the counted\_iterator will compare equal to std::default\_sentinel, signifying the end of the range.

\subsection{copy, move, copy\_backwards, move\_backwards}

When copying/moving a range, we need to avoid overwriting the yet to be copied/moved elements from the source range. The standard offers two directions of copying to prevent this issue. We will start with the forward version:

\cppversions{\texttt{copy}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{move}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range -> output\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{}{}

The output iterator is not permitted to be within [first, last) (of the input range). Consequently, only the tail of the output range can overlap with the input range.

\begin{box-note}
\begin{cppcode}
std::vector<std::string> data{ "a", "b", "c", "d", "e", "f"};

std::copy(data.begin(), data.begin()+3, data.begin()+3);
// data = { "a", "b", "c", "a", "b", "c" }

// Overlapping case:
std::copy(std::next(data.begin()), data.end(), data.begin());
// data = { "b", "c", "a", "b", "c", "c" }
\end{cppcode}
\end{box-note}

Move operates identically, except it casts each element to an rvalue before the assignment, turning copies into moves.

\begin{box-note}
\begin{cppcode}
std::vector<std::string> data{ "a", "b", "c", "d", "e", "f"};

std::move(data.begin(), data.begin()+3, data.begin()+3);
// data = { ?, ?, ?, "a", "b", "c" }
\end{cppcode}
\end{box-note}

Significantly, whether std::move will move depends on the underlying element type. If the underlying type is copy-only, std::move will behave identically to std::copy.

\begin{box-note}
\begin{cppcode}
struct CopyOnly {
    CopyOnly() = default;
    CopyOnly(const CopyOnly&) = default;
    CopyOnly& operator=(const CopyOnly&) { 
      std::cout << "Copy assignment.\n";
      return *this;
    };
};

std::vector<CopyOnly> test(6);

std::move(test.begin(), test.begin()+3, test.begin()+3);
// 3x Copy assignment
\end{cppcode}
\end{box-note}

We can also emulate std::move by using the previously mentioned move\_iterator adapter.

\begin{box-note}
\begin{cppcode}
std::vector<std::string> data{ "a", "b", "c", "d", "e", "f"};

std::copy(std::make_move_iterator(data.begin()), std::make_move_iterator(data.begin()+3), 
          data.begin()+3);
// data = { ?, ?, ?, "a", "b", "c" }
\end{cppcode}
\end{box-note}

When we need to copy to an overlapping range that isn’t suitable for forward copy, we can use the backward variant that copies in the opposite direction.

\cppversions{\texttt{copy\_backward}}{\CC98}{\CC20}{N/A}{\CC20}
\cppversions{\texttt{move\_backward}}{\CC11}{\CC20}{N/A}{\CC20}

\constraints{\texttt{bidirectional\_range -> bidirectional\_iterator}}{}{}{}

The output iterator cannot be within (first, last] and will be treated as the end iterator for the destination range, meaning that the algorithm will write the first value to std::prev(end).

\begin{box-note}
\begin{cppcode}
std::vector<std::string> data{ "a", "b", "c", "d", "e", "f"};

std::vector<std::string> out(9, "");
std::copy_backward(data.begin(), data.end(), out.end());
// "", "", "", "a", "b", "c", "d", "e", "f"

std::copy_backward(data.begin(), std::prev(data.end()), data.end());
// data = { "a", "a", "b", "c", "d", "e" }
\end{cppcode}
\end{box-note}

Similar to fill\_n and generate\_n, the standard also provides a copy\_n variant suitable for non-random-access ranges.

\cppversions{\texttt{copy\_n}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_iterator -> output\_iterator}}{\texttt{forward\_iterator -> forward\_iterator}}{}{}

The algorithm cannot check whether the requested count is valid and does not go out of bounds, so this burden is on the caller.

\begin{box-note}
\begin{cppcode}
std::list<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector<int> out;

std::copy_n(data.begin(), 5, std::back_inserter(out));
// out == { 1, 2, 3, 4, 5 }
\end{cppcode}
\end{box-note}

\subsection{copy\_if, remove\_copy, remove\_copy\_if}

We can use copy\_if or remove\_copy\_if when we need to select only some of the elements to be copied.

\cppversions{\texttt{copy\_if}}{\CC11}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{remove\_copy, remove\_copy\_if}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range -> output\_range}}{\texttt{forward\_range -> forward\_iterator}}{N/A}{\texttt{unary\_predicate}}

These two algorithms provide the same logic, with opposite semantics: copy\_if will copy elements for which the predicate returns true, and remove\_copy\_if will copy elements for which the predicate returns false. Finally, remove\_copy copies elements that do not match the provided value.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{ 1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector<int> even, odd, no_five;

auto is_even = [](int v) { return v % 2 == 0; };

std::ranges::copy_if(data, std::back_inserter(even), is_even);
// even == { 2, 4, 6, 8 }

std::ranges::remove_copy_if(data, std::back_inserter(odd), is_even);
// odd == { 1, 3, 5, 7, 9 }

std::ranges::remove_copy(data, std::back_inserter(no_five), 5);
// no_five == { 1, 2, 3, 4, 6, 7, 8, 9 }
\end{cppcode}
\end{box-note}

\subsection{sample}

A different twist on a selective copy is the sample algorithm.

\cppversions{\texttt{sample}}{\CC17}{N/A}{N/A}{\CC20}

\constraints{\texttt{forward\_range -> output\_iterator}}{}{}{}
\constraints{\texttt{input\_range -> random\_access\_iterator}}{}{}{}

The sample algorithm will copy a random selection of N elements from the source range to the destination range utilising the provided random number generator.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector<int> out;

std::sample(data.begin(), data.end(), std::back_inserter(out),
            5, std::mt19937{std::random_device{}()});
// e.g. out == {2, 3, 4, 5, 9} (guaranteed ascending, because source range is ascending)
\end{cppcode}
\end{box-note}

The two domains of this algorithm are due to the stable nature of the sampling, maintaining the order of elements from the source range.

This feature requires either the input range to be at least a forward range or the destination range needs to be a random-access range.

\subsection{replace\_copy, replace\_copy\_if}

We discussed the replace algorithm in a previous article in the series. The copy variants work identical, replacing values matching a predicate or a provided value. However, the result is output to a destination range instead of the replacement applied in place.

\cppversions{\texttt{replace\_copy, replace\_copy\_if}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range -> output\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{N/A}{\texttt{unary\_predicate}}

The replace\_copy\_if variant replaces elements for which the predicate returns true. The replace\_copy replaces elements that match the provided value.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector<int> out, odd;

std::ranges::replace_copy(data, std::back_inserter(out), 5, 10);
// out == { 1, 2, 3, 4, 10, 6, 7, 8, 9 }

auto even = [](int v) { return v % 2 == 0; };
std::ranges::replace_copy_if(data, std::back_inserter(odd), even, -1);
// odd == { 1, -1, 3, -1, 5, -1, 7, -1, 9 }
\end{cppcode}
\end{box-note}

\subsection{reverse\_copy, rotate\_copy}

The last two algorithms from the copiers category change the order of copied elements.

\cppversions{\texttt{reverse\_copy}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{bidirectional\_range -> output\_iterator}}{\texttt{bidirectional\_range -> forward\_iterator}}{}{}

Not to be confused with copy\_backwards, which maintains the original order of elements, reverse\_copy will reverse the order of elements copied.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector<int> out;

std::ranges::reverse_copy(data, std::back_inserter(out));
// out == { 9, 8, 7, 6, 5, 4, 3, 2, 1 }
\end{cppcode}
\end{box-note}

\cppversions{\texttt{rotate\_copy}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(forward\_range, forward\_iterator) -> output\_iterator}}{\texttt{(forward\_range, forward\_iterator) -> forward\_iterator}}{}{}

Following the logic of the rotate algorithm, rotate\_copy will first copy the elements starting from the designated middle element and then follow with the remaining elements from the beginning of the range.

\begin{box-note}
\begin{cppcode}
std::vector<int> data{1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector<int> out;

std::ranges::rotate_copy(data, data.begin()+4, std::back_inserter(out));
// out == { 5, 6, 7, 8, 9, 1, 2, 3, 4 }
\end{cppcode}
\end{box-note}

\section{Heap and heap}

The heap and uninitialized memory algorithms represent a niche category in the overall algorithm arsenal, primarily because the standard library offers more convenient alternatives that, on the other hand, offer less control. Therefore, if you desire or need the control, you can use these algorithms as a foundation for your custom implementation.

\subsection{Heap data structure}

The standard offers a convenient wrapper for a max heap data structure through std::priority\_queue. However, when using std::priority\_queue, we lose access to the underlying data, which might be inconvenient.

\cppversions{\texttt{make\_heap, push\_heap, pop\_heap, sort\_heap}}{\CC98}{\CC20}{N/A}{\CC20}

\constraints{\texttt{random\_access\_range}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

% mention complexity

For comparison, let’s implement a simple version of the topk algorithm that returns the top k elements from a range (similar to partial\_sort\_copy):

\begin{box-note}
\begin{cppcode}
auto topk_queue(std::input_iterator auto begin, std::sentinel_for<decltype(begin)> auto end, 
                size_t k) {

    using vtype = std::iter_value_t<decltype(begin)>;
    std::priority_queue<vtype, std::vector<vtype>, std::greater<vtype>> pq;

    while (begin != end) {
        pq.push(*begin);
        if (pq.size() > k)
            pq.pop();
        ++begin;
    }

    std::vector<vtype> result(k);
    for (auto &el: result | std::views::reverse) {
        el = std::move(pq.top());
        pq.pop();
    }
    return result;    
}
\end{cppcode}
\end{box-note}

When using the priority queue, we can utilize the simple push() and pop() interface provided (lines 8 and 10). However, extracting all data from the queue is only possible by repeatedly applying pop() until the queue is empty (line 17).

\begin{box-note}
\begin{cppcode}
auto topk(std::input_iterator auto begin, std::sentinel_for<decltype(begin)> auto end, 
          size_t k) {
          
    std::vector<std::iter_value_t<decltype(begin)>> result;
    while (begin != end) {
        result.push_back(*begin);
        std::ranges::push_heap(result, std::greater<>{});
        if (result.size() > k) {
            std::ranges::pop_heap(result, std::greater<>{});
            result.pop_back();
        }
        ++begin;
    }
    
    std::ranges::sort_heap(result, std::greater<>{});
    return result;    
}
\end{cppcode}
\end{box-note}

When using the heap algorithms, we need to manually manage the underlying data structure (lines 6–7 and 9–10). However, we do not need to extract the data, and on top of that, we could omit the final sort\_heap (line 15) if we do not need the top k elements in sorted order.

Our example does not utilize std::make\_heap, as we start from an empty range, which is a valid heap.

\cppversions{\texttt{is\_heap, is\_heap\_until}}{\CC11}{\CC20}{N/A}{\CC20}

\constraints{\texttt{random\_access\_range}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

The two test algorithms check the heap invariant. Max heap is a binary tree, where each child is equal to or less than the parent element. The is\_heap variant returns a boolean, where the is\_heap\_until returns an iterator denoting the leading part of the range, which satisfies the max heap invariant.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = {1, 2, 3, 4, 5, 6, 7, 8, 9};

assert(!std::is_heap(data.begin(), data.end()));
assert(std::is_heap_until(data.begin(), data.end()) == std::next(data.begin()));

std::make_heap(data.begin(), data.end());

assert(std::is_heap(data.begin(), data.end()));
assert(std::is_heap_until(data.begin(), data.end()) == data.end());
\end{cppcode}
\end{box-note}

Before applying make\_heap, only the first element is in the correct heap order (parent of 2 is 1, which violates the max heap invariant). Therefore, is\_heap returns false (line 3) and is\_heap\_until returns an iterator to the second element (line 4).

After applying make\_heap, the entire range is in heap order, is\_heap returns true (line 8), and is\_heap\_until returns the end of range iterator (line 9).

Notably, is\_heap(begin, is\_heap\_until(begin, end)) will always return true.

\subsection{Working with uninitialized memory}

The second category of algorithms we will talk about today are algorithms that operate on uninitialized memory. Like the heap algorithms, you should prefer higher-level abstractions (e.g. polymorphic memory resource). However, when working with uninitialized memory, using these algorithms is preferable to implementing all the functionality from scratch.

We first need to start with obtaining a block of uninitialized memory, and there are two valid approaches to that in C++. First, we can allocate an array of char with the appropriate alignment and size. Because char* is permitted to alias any other pointer type, we can reinterpret\_cast the resulting buffer to our desired type.

Alternatively, we can use the global operator new, that since C++17 accepts an alignment parameter and returns a pointer to void. We can then cast this pointer to the desired type using static\_cast.

Here is an example of allocating (and deallocating) space for ten std::string objects using the global operator new:

\begin{box-note}
\begin{cppcode}
auto* begin = static_cast<std::string*>(
                  ::operator new[](sizeof(std::string)*10, 
                                   static_cast<std::align_val_t>(alignof(std::string))));

::operator delete[](begin, static_cast<std::align_val_t>(alignof(std::string)));
\end{cppcode}
\end{box-note}

This example contains a lot of spelling, so let’s step through:

\begin{itemize}
    \item First, we need sizeof(std::string)*10 bytes, which is the first parameter of the new operator (line 2).
    \item Whenever allocating raw memory, we must ensure that the alignment requirement of the objects we intend to store in this memory is satisfied.
    \item To prevent overload resolution collisions, the new operator takes alignment as align\_val\_t instead of the size\_t returned by alignof, so we need to use an additional static\_cast (line3).
    \item Finally, we must cast the void pointer to the desired element type (line 1).
    \item When deleting, we need to make sure that we use the matching version (here, the array version) of operator delete and supply alignment following the same logic as previously mentioned.
\end{itemize}

Here is an example of using a char buffer on the stack:

\begin{box-note}
\begin{cppcode}
alignas(alignof(std::string)) char buff[sizeof(std::string)*10];
auto *begin = reinterpret_cast<std::string*>(buff);
\end{cppcode}
\end{box-note}

Because the memory lives on the stack, we do not need a deallocation step.

Importantly, all we have in both snippets of code is raw memory. There are no objects of type std::string created or destroyed. Also, note the difference in static\_cast vs reinterpret\_cast. The static\_cast is for converting between related types (void* is related to all pointer types). The reinterpret\_cast is for converting between unrelated types (char* can alias any other pointer but is not a related type to std::string*).

\subsection{construct\_at, destroy\_at}

The construct\_at and destroy\_at algorithms will construct/destroy a single element at a given address. If additional arguments are specified, construct\_at will forward these to the objects’ constructor.

\cppversions{\texttt{construct\_at}}{\CC20}{\CC20}{N/A}{\CC20}
\cppversions{\texttt{destroy\_at}}{\CC17}{\CC20}{N/A}{\CC20}

\begin{box-note}
\begin{cppcode}
alignas(alignof(std::string)) char mem[sizeof(std::string)];
auto *ptr = reinterpret_cast<std::string*>(mem);

std::construct_at(ptr, 8, 'X');
// *ptr == "XXXXXXXX", ptr->length() == 8
std::destroy_at(ptr);
\end{cppcode}
\end{box-note}

In this example, the construct\_at algorithm creates a std::string object using the arguments eight and ‘X’ (line 4), which results in a string filled with eight copies of the X character.

\subsection{uninitialized\_default\_construct, uninitialized\_value\_construct, uninitialized\_fill, destroy}

These three algorithms cover the default initialization, value initialization and copy initialization of elements. Destroy provides destruction of objects without deallocating the underlying memory.

\cppversions{\texttt{uninitialized\_fill}}{\CC98}{N/A}{\CC17}{\CC20}
\cppversions{\texttt{uninitialized\_default\_construct, uninitialized\_value\_construct, destroy}}{\CC17}{N/A}{\CC17}{\CC20}

\constraints{\texttt{forward\_range, forward\_iterator}}{}{}{} % Cleanup the counted variant situation

All these algorithms have counted variants that accept an iterator and the count of elements:

\begin{box-note}
\begin{cppcode}
alignas(alignof(std::string)) char buffer[sizeof(std::string)*10];
auto *begin = reinterpret_cast<std::string*>(buffer);
auto *it = begin;

std::uninitialized_default_construct_n(it, 3);
it += 3;
std::uninitialized_fill_n(it, 2, "Hello World!");
it += 2;
std::uninitialized_value_construct_n(it, 3);
it += 3;
std::uninitialized_fill_n(it, 2, "Bye World!");

// {"", "", "", "Hello World!", "Hello World!", "", "", "", "Bye World!", "Bye World!"}

std::destroy_n(begin, 10);
\end{cppcode}
\end{box-note}

For std::string, there is no difference between default and value initialization. In both cases, we end up with an empty string.

\subsection{uninitialized\_copy, uninitalized\_move}

\cppversions{\texttt{uninitialized\_copy}}{\CC98}{N/A}{\CC17}{\CC20}
\cppversions{\texttt{uninitialized\_move}}{\CC17}{N/A}{\CC17}{\CC20}

\constraints{\texttt{input\_range -> forward\_iterator}}{\texttt{forward\_range -> forward\_iterator}}{}{}
\constraints{\texttt{input\_iterator -> forward\_iterator}}{\texttt{forward\_iterator -> forward\_iterator}}{}{}

These algorithms follow the logic of copy and move algorithms. However, because the destination range is uninitialized memory, these turn into copy and move constructions instead copy and move assignments.

\begin{box-note}
\begin{cppcode}
alignas(alignof(std::string)) char buff1[sizeof(std::string)*5];
alignas(alignof(std::string)) char buff2[sizeof(std::string)*5];
std::vector<std::string> data = {"hello", "world", "and", "everyone", "else"};

auto *bg1 = reinterpret_cast<std::string*>(buff1);
std::uninitialized_copy(data.begin(), data.end(), bg1);
// buff1 == { "hello", "world", "and", "everyone", "else"}
// data == { "hello", "world", "and", "everyone", "else"}
std::destroy_n(bg1, 5);

auto *bg2 = reinterpret_cast<std::string*>(buff2);
std::uninitialized_move(data.begin(), data.end(), bg2); 
// buff2 == { "hello", "world", "and", "everyone", "else"}
// data == { ?, ?, ?, ?, ?}
std::destroy_n(bg2, 5);
\end{cppcode}
\end{box-note}

\subsubsection{Transactional behaviour}

The main benefit of using the uninitialized memory algorithms is that they correctly handle transactional behaviour. Transactionality is important in cases where the constructor of an object can throw. If one of the objects fails to construct, the algorithms will correctly roll back by destructing already constructed objects.

We can observe this behaviour by constructing a toy type that throws on the third construction:

\begin{box-note}
\begin{cppcode}
struct Custom {
  static int cnt;
  Custom() { 
    if (++cnt >= 3)
      throw std::runtime_error("Deliberate failure."); 
    std::cout << "Custom()\n";
  }
  ~Custom() {
    std::cout << "~Custom()\n";
  }
};

int Custom::cnt = 0;

alignas(alignof(Custom)) char buffer[sizeof(Custom)*10];
auto *begin = reinterpret_cast<Custom*>(buffer);

try {
  std::uninitialized_default_construct_n(begin, 10);
  std::destroy_n(begin, 10); // not reached
} catch (std::exception& e) {
  std::cout << e.what() << "\n";
}
/* Output:
Custom()
Custom()
~Custom()
~Custom()
Deliberate failure.
*/
\end{cppcode}
\end{box-note}

Because the custom class throws on the constructor’s third call, we will see the std::uninitialized\_default\_construct algorithm create two instances and then immediately destroy two instances of Custom, after which it rethrows the exception.

\section{Searching and min-max}

The search and min-max algorithms we will cover today all operate linearly with O(n) (when operating on a single range) or O(m*n) complexity (when operating on two ranges). We have covered faster lookup algorithms in article number three.

\subsection{find, find\_if, find\_if\_not}

The std::find algorithm provides a basic linear search. The standard provides three variants, one searching by value and two variants using a predicate.

\cppversions{\texttt{find, find\_if}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{find\_if\_not}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{\texttt{operator==} (\texttt{find})}{\texttt{unary\_predicate}}

A typical example of searching by value is finding delimiters:

\begin{box-note}
\begin{cppcode}
std::string data = "John;Doe;April;1;1900;";
auto it = data.begin(), token = data.begin();
std::vector<std::string> out;

while ((token = find(it, data.end(), ';')) != data.end()) {
    out.push_back("");
    std::copy(it, token, std::back_inserter(out.back()));
    it = std::next(token);
}
// out == { "John", "Doe", "April", "1", "1900" }
\end{cppcode}
\end{box-note}

Because std::find\_if and std::find\_if\_not compare elements using a predicate, we can search for categories of values. In this example, we use std::find\_if\_not to find the first non-white-space character from either direction:

\begin{box-note}
\begin{cppcode}
std::string data = "   hello world!  ";
auto begin = std::find_if_not(data.begin(), data.end(), 
                              [](char c) { return isspace(c); });
if (begin == data.end()) // only spaces
    return 0;

std::string out;
std::copy(begin, std::find_if_not(data.rbegin(), data.rend(), 
                                  [](char c) { return isspace(c); }).base(), 
          std::back_inserter(out));
// out == "hello world!"
\end{cppcode}
\end{box-note}

\subsection{adjacent\_find, search\_n}

As the name suggests, std::adjacent\_find searches for adjacent elements in the range.

\cppversions{\texttt{adjacent\_find}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

The basic version searches for a pair of adjacent elements using operator== or the binary predicate if provided. In either case, the pair will be returned by an iterator to the first of the two elements.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 1, 2, 3, 4, 4, 5, 6, 7, 8, 9 };
auto it1 = std::adjacent_find(data.begin(), data.end());
// *it1 == 4, i.e. {4, 4}

auto it2 = std::adjacent_find(data.begin(), data.end(), 
                              [](int l, int r) { return l + r > 10; });
// *it2 == 5, i.e. {5, 6}
\end{cppcode}
\end{box-note}

If we want to search for more than two consecutive equal elements, we can use std::search\_n.

\cppversions{\texttt{search\_n}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

The algorithm accepts the desired number of instances and the value to compare against. If found, the sequence is returned using an iterator to the first element of the sequence.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 1, 0, 5, 8, 3, 3, 2 };

auto it1 = std::search_n(data.begin(), data.end(), 2, 3);
// *it1 == 3, i.e. {3, 3}

auto it2 = std::search_n(data.begin(), data.end(), 3, 3, 
                         [](int l, int r) { return l % 5 == r % 5; });
// *it2 == 8, i.e. {8, 3, 3}

auto it3 = std::search_n(data.begin(), data.end(), 2, 0);
// it3 == data.end(), i.e. not found
\end{cppcode}
\end{box-note}

Note that the behaviour of std::search\_n does not match the typical naming. The range is still specified entirely using a begin and end iterator. The \_n refers to the number of instances instead.

\subsection{find\_first\_of}

Using std::find\_if, we can easily search for a category of elements. However, sometimes it is more convenient to list the elements we are looking for exhaustively.

\cppversions{\texttt{find\_first\_of}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(input\_range, forward\_range)}}{\texttt{(forward\_range, forward\_range)}}{\texttt{operator==}}{\texttt{binary\_predicate}}

Note that we are shifting from linear search to O(m*n) time complexity since, for each element of the first range, we need to compare it to all elements in the second range (worst case).

\begin{box-note}
\begin{cppcode}
std::vector<int> haystack = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
std::vector<int> needles = { 7, 5, 3 };
auto it = std::find_first_of(haystack.begin(), haystack.end(), 
                             needles.begin(), needles.end());
// *it == 3, i.e. haystack[2]
\end{cppcode}
\end{box-note}

\subsection{search, find\_end}

Finally, we arrive at algorithms that search for a sub-sequence in a sequence.

\cppversions{\texttt{search, find\_end}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(forward\_range, forward\_range)}}{}{\texttt{operator==}}{\texttt{binary\_predicate}}

The std::search returns the first instance of the sub-sequence, and std::find\_end returns the last instance of the sub-sequence.

\begin{box-note}
\begin{cppcode}
std::string haystack = "abbabba";
std::string needle = "bba";
auto it1 = std::search(haystack.begin(), haystack.end(), 
                       needle.begin(), needle.end());
// it1..end == "bbabba"

auto it2 = std::find_end(haystack.begin(), haystack.end(), 
                         needle.begin(), needle.end());
// it2..end == "bba"
\end{cppcode}
\end{box-note}

\subsubsection{Searchers}

Since C++17, we also can specify custom searchers for the search algorithm. Apart from the basic one, the standard implements Boyer-Moore and Boyer-Moore-Horspool string searchers that offer different best-case, worst-case and average complexity.

\begin{box-note}
\begin{cppcode}
std::string haystack = "abbabba";
std::string needle = "bba";

auto it1 = std::search(haystack.begin(), haystack.end(), 
                       std::default_searcher(needle.begin(), needle.end()));

auto it2 = std::search(haystack.begin(), haystack.end(), 
                       std::boyer_moore_searcher(needle.begin(), needle.end()));

auto it3 = std::search(haystack.begin(), haystack.end(), 
                       std::boyer_moore_horspool_searcher(needle.begin(), needle.end()));
// it1 == it2 == it3
\end{cppcode}
\end{box-note}

\subsection{count, count\_if}

The std::count and std::count\_if algorithms count the number of matching elements.

\cppversions{\texttt{count, count\_if}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{input\_range}}{\texttt{forward\_range}}{\texttt{operator==} (\texttt{count})}{\texttt{unary\_predicate} (\texttt{count\_if})}

The element searched for can be specified using a value or a predicate.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 1, 2, 3, 2, 1, 2, 3, 2, 1 };
auto one_cnt = std::count(data.begin(), data.end(), 1);
// one_cnt == 3

auto even_cnt = std::count_if(data.begin(), data.end(), 
                              [](int v) { return v % 2 == 0; });
// even_cnt == 4
\end{cppcode}
\end{box-note}

\subsection{equal, mismatch}

In a previous article, we discussed lexicographical comparisons using std::lexicographical\_compare and std::lexicographical\_compare\_three\_way. The std::equal and std::mismatch algorithms provide a simpler equality comparison, with std::equal returning a simple boolean and std::mismatch returning a pair of iterators denoting the mismatching elements.

\cppversions{\texttt{equal, mismatch}}{\CC98}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{(input\_range, input\_iterator)}}{\texttt{(forward\_range, forward\_iterator)}}{\texttt{operator==}}{\texttt{binary\_predicate}}
\constraints{\texttt{(input\_range, input\_range)} since \CC14}{(forward\_range, forward\_range)}{\texttt{operator==}}{\texttt{binary\_predicate}}

The default operator== can be replaced by a binary predicate for both algorithms.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { -1, -2, -3, -4, -5 };

assert(!std::equal(first.begin(), first.end(), second.begin()));

assert(std::equal(first.begin(), first.end(), second.begin(), 
                  [](int l, int r) { return std::abs(l) == std::abs(r); }));
\end{cppcode}
\end{box-note}

The std::mismatch algorithm returns a pair of iterators whose underlying elements do not match.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { 1, 2, 2, 4, 5 };

auto it_pair = std::mismatch(first.begin(), first.end(), second.begin());
// *it_pair.first == 3, *it_pair.second == 2
\end{cppcode}
\end{box-note}

Both std::equal and std::mismatch provide two variants of specifying the second range. The distinction is important here. If we specify the second range using an iterator, we cannot detect a mismatch in the size of the ranges.

\begin{box-note}
\begin{cppcode}
std::vector<int> first = { 1, 2, 3, 4, 5 };
std::vector<int> second = { 1, 2, 3, 4, 5, 6 };

assert(std::equal(first.begin(), first.end(), 
                  second.begin()));
// Cannot detect mismatch in size.

assert(!std::equal(first.begin(), first.end(), 
                   second.begin(), second.end()));
// Different number of elements -> not equal.
\end{cppcode}
\end{box-note}

\subsection{clamp}

The std::clamp algorithm is one of the few algorithms that do not operate on ranges.

\cppversions{\texttt{clamp}}{\CC17}{\CC17}{N/A}{\CC20}

The clamp algorithm will clamp the given value in between the provided minimum and maximum:

\begin{itemize}
    \item if $value < minimum$, std::clamp returns the minimum
    \item if $maximum < value$, std::clamp returns the maximum
    \item otherwise, std::clamp returns the value
\end{itemize}

\begin{box-note}
\begin{cppcode}
int a = std::ranges::clamp(10, 0, 20);
// a == 10 (0 < 10 && 10 < 20)

int b = std::clamp(-20, 0, 20);
// b == 0 (-20 < 0)

int c = std::clamp(30, 0, 20);
// c == 20 ( 30 > 20 )
\end{cppcode}
\end{box-note}

\subsection{min, max, minmax}

The first group of min-max algorithms also do not operate on ranges (except a C++20 range variant).

\cppversions{\texttt{min, max}}{\CC98}{\CC14}{N/A}{\CC20}
\cppversions{\texttt{minmax}}{\CC11}{\CC14}{N/A}{\CC20}

\constraints{\texttt{initializer\_list} since \CC14}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}
\constraints{\texttt{input\_range} \CC20 range version only}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

Until C++14, the only variants available operated on two elements only, returning a const-reference. Then, the C++14 standard introduced a variant that operates on an initializer list, which returns by value. Finally, C++20 introduced a range variant that operates on input ranges and returns by value.

\begin{box-note}
\begin{cppcode}
auto i = std::min(1, 2);
// i == 1

auto j = std::max(1, 2);
// j == 2

auto v = std::minmax({5, 3, -2, 0});
// v.first == -2, v.second == 5

std::list<int> data = {5, 3, -2, 0};
auto k = std::ranges::min(data);
// k == -2
\end{cppcode}
\end{box-note}

\subsection{min\_element, max\_element, minmax\_element}

The element versions of min-max algorithms operate on ranges and, instead of returning by const-reference or value, return an iterator to the minimum or maximum elements.

\cppversions{\texttt{min\_element, max\_element}}{\CC98}{\CC20}{\CC17}{\CC20}
\cppversions{\texttt{minmax\_element}}{\CC11}{\CC20}{\CC17}{\CC20}

\constraints{\texttt{forward\_range}}{}{\texttt{operator<}}{\texttt{strict\_weak\_ordering}}

All variants require forward\_range as they return iterators to the min-max elements instead of a value.

\begin{box-note}
\begin{cppcode}
std::vector<int> data = { 5, 3, -2 , 0};
auto i = std::min_element(data.begin(), data.end());
// *i == -2 (i.e. data[2])
auto j = std::max_element(data.begin(), data.end());
// *j == 5 (i.e. data[0])

auto k = std::minmax_element(data.begin(), data.end());
// *k.first == -2, *k.second == 5
\end{cppcode}
\end{box-note}