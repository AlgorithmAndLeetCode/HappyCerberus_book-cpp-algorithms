\chapter{Introduction to Ranges}

The \CC20 standard introduced the Ranges library (a.k.a. STLv2), which effectively replaces existing algorithms and facilities.
In this chapter, we will go over the main changes.

Note that Ranges are one of the features that landed in \CC20 in a partial state.
Despite \CC23 introducing plenty of additional features, we already know that many features will still not make it into \CC23.

\section{Reliance on concepts}

The standard has always described what is required of each argument passed to an algorithm. However, this description was purely informative, and the language did not offer first-class tools to enforce these requirements. Because of this, the error messages were often confusing.

Concepts are a new C++20 language feature that permits library implementors to constrain the arguments of generic code. Concepts are beyond the scope of this book; however, there are two consequences worth noting.

First, the definitions of all concepts are now part of the standard library, e.g. you can look up what exactly it means for a type to be a \cpp{random_access_range} and also use these concepts to constrain your code.

\begin{box-note}
\footnotesize Example of using standard concepts in user code. The function accepts any random access range as the first argument and an output iterator with the same underlying type as the second argument.
\tcblower
\cppfile{code_examples/ranges/concepts_code.h}
\end{box-note}

Second, error messages now reference unsatisfied constraints instead of reporting an error deep in the library implementation.

\begin{minted}[fontsize=\footnotesize]{cpp}
note: candidate: 'template<class _Iter, class _Sent, class _Comp, class _Proj>
    requires (random_access_iterator<_Iter>)
\end{minted}

\section{Notion of a Range}

Non-range algorithms have always operated strictly using iterators. Conceptually, the range of elements has been defined by two iterators \cpp{[first, last)} or when working with all elements from a standard data structure \cpp{[begin, end)}.

Range algorithms formally define a range as an iterator and a sentinel pair. Moving the sentinel to a different type unlocks the potential to simplify code where an end iterator doesn't naturally map to an element. The standard offers two default sentinel types, \cpp{std::default_sentinel} and \cpp{std::unreachable_sentinel}.

Apart from simplifying certain use cases, sentinels also allow for infinite ranges and potential performance improvements.

\begin{box-note}
\footnotesize Example of an infinite range when the data guarantees termination. Using \cpp{std::unreachable_sentinel} causes the boundary check to be optimized-out, removing one comparison from the loop.
\tcblower
\cppfile{code_examples/ranges/infinite_code.h}
\end{box-note}

We can only use this approach when we have a contextual guarantee that the algorithm will terminate without going out of bounds. However, this removes one of the few instances when algorithms couldn't perform as well as handwritten code.

And finally, with the introduction of the range, algorithms now provide range overloads, leading to more concise and easier-to-read code.

\begin{box-note}
\footnotesize Example of using the range overload of \cpp{std::sort}.
\tcblower
\cppfile{code_examples/ranges/rangified_code.h}
\end{box-note}

\section{Projections}

Each range algorithm comes with an additional argument, the projection.
The projection is effectively a baked-in transform operation applied before an element is passed into the main functor.

The projection can be any invocable, which includes member pointers.




\section{TODO}

\begin{box-note}
\begin{cppcode}
std::vector<int> dt = {1, 4, 2, 3};
std::ranges::sort(dt);
\end{cppcode}
\end{box-note}

\subsection{Projections}

A massive new feature that, on the surface, seems trivial is the support for projections. A projection is a unary invocable that is applied to every element.

This often completely removes the need to write complex lambdas, and when it doesn’t, it simplifies them significantly. An invocable is an extension of callable and also accepts member pointers.

\begin{box-note}
\begin{cppcode}
struct Account {
    std::string owner;
    double value();
    double base();
};
std::vector<Account> acc = get_accounts();
// member
std::ranges::sort(acc,{},&Account::owner);
// member function
std::ranges::sort(acc,{},&Account::value);
// lambda
std::ranges::sort(acc,{},[](const auto& a) { 
    return a.value()+a.base(); 
});
\end{cppcode}
\end{box-note}

Without projections, we would have to include this logic as part of a custom comparator.

\begin{box-note}
\begin{cppcode}
std::vector<int> dt = { 1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector<int> result;
std::ranges::transform(dt, 
                       dt | std::views::reverse,
                       std::back_inserter(result),
                       std::minus<void>(),
                       [](int v) { return v*v; },
                       [](int v) { return v*v; });
std::ranges::copy(result, 
                  std::ostream_iterator<int>(std::cout, ","));
\end{cppcode}
\end{box-note}

This is a slight foreshadowing for views, but I wanted to include another example that utilized two ranges as input. In such a case, we get two separate projections. Note that these projections can also return different return types, as long as they match up with the operation (here std::minus).

\subsection{The small stuff}

One last “small” feature I wanted to mention here is the prevention of dangling iterators. Mainly because even if you don’t care for it, you might find use-cases for this particular pattern in your codebase.

\begin{box-note}
\begin{cppcode}
auto good = "1234567890";
auto sep1 = std::ranges::find(std::string_view(good), '0');
std::cout << *sep1 << "\n";
auto bad = 1234567890;
auto sep2 = std::ranges::find(std::to_string(bad), '0');
std::cout << *sep2 << "\n";
\end{cppcode}
\end{box-note}

You might recognize the problem here. If we weren’t using range variants of the algorithms, the “bad” variant would crash at runtime. However, with ranges, this code will not compile. When a range-based algorithm is invoked with a temporary range that owns its elements, the algorithm will return a special iterator std::ranges::dangling.

Note that the first variant with a std::string\_view will still work just fine. String view is a type of range that doesn’t own its elements, and its iterators are freestanding (they don’t depend on the instance of string\_view), so it is perfectly valid to pass such temporary into a range-based algorithm.

To opt-in your ranges to work as temporaries, you need to specialize the enable\_borrowed\_range constant:

\begin{box-note}
\begin{cppcode}
template<typename T>
inline constexpr bool 
    std::ranges::enable_borrowed_range<MyView<T>> = true;
\end{cppcode}
\end{box-note}

\section{Composable views}

One of the core problems with old STL algorithms is that they are not easily composable. As a result, the code using algorithms is often quite verbose and, when working with immutable data, requires additional copies.

Views are trying to address this issue, making code that relies on standard algorithms less verbose and more explicit.

\subsection{Views}

Views are simply ranges that are cheap to copy and move (in constant time). Because of this, a view cannot own the elements it is viewing. One exception is std::views::single which owns the single element it is viewing.

Views compose at compile time with the expectation that the compiler will inline the code.

For example, the following code will print out the last three elements of the range. We first reverse the range, then take the first three elements, and finally reverse the range again (note that there is std::views::drop that does this directly).

\begin{box-note}
\begin{cppcode}
namespace rv = std::ranges::views;
std::vector<int> dt = {1, 2, 3, 4, 5, 6, 7};
for (int v : rv::reverse(rv::take(rv::reverse(dt),3))) {
    std::cout << v << ", ";
}
std::cout << "\n";
\end{cppcode}
\end{box-note}

\subsection{View closure objects}

Because of the often deep nesting, the functional syntax of composing views can be cumbersome to write and read.

Fortunately, ranges bring us another approach for compositing views. Views in the std::views namespace are actually view closure objects. These are inline constexpr constants with each std::ranges::xxx\_view mapping to an std::views::xxx object. These objects overload the operator() for functional syntax as seen above and operator| for pipe-style compositing.

\begin{box-note}
\begin{cppcode}
namespace rv = std::ranges::views;
std::vector<int> dt = {1, 2, 3, 4, 5, 6, 7};
for (int v : dt | rv::reverse | rv::take(3) | rv::reverse) {
    std::cout << v << ", ";
}
std::cout << "\n";
\end{cppcode}
\end{box-note}

Note that while views do not own their elements, they do not change the mutability of underlying data. Here, we iterate over odd elements of the array and multiply them by two.

\begin{box-note}
\begin{cppcode}
namespace rv = std::ranges::views;
std::vector<int> dt = {1, 2, 3, 4, 5, 6, 7};
auto odd = [](std::integral auto v) { return v % 2 == 1; };
for (auto& v : dt | rv::filter(odd)) {
    v *= 2;
}
\end{cppcode}
\end{box-note}

\section{FizzBuzz three ways}

Let’s have a look at some concrete examples of Ranges. We will write three versions of FizzBuzz:

\begin{itemize}
    \item a range-ified coroutine generator
    \item a generative approach using algorithms
    \item a composition approach using views
\end{itemize}

As mentioned at the beginning of the article, the current support in C++20 is a bit lacking. Therefore, I will rely on the range v3 library.

\subsection{Coroutine generator}

Writing a coroutine FizzBuzz generator is almost identical to the typical implementation:

\begin{box-note}
\begin{cppcode}
ranges::experimental::generator<std::string> fizzbuzz() {
    for (int i = 1; ; i++) {
        std::string result;
        if (i % 3 == 0) result += "Fizz";
        if (i % 5 == 0) result += "Buzz";
        if (result.empty()) co_yield std::to_string(i);
        else co_yield result;
    }
}
\end{cppcode}
\end{box-note}

However, if we use the generator<> from range v3 library, we can also use the invoked coroutine as a range.

\begin{box-note}
\begin{cppcode}
for (auto s : fizzbuzz() | ranges::views::take(20)) {
    std::cout << s << "\n";
}
\end{cppcode}
\end{box-note}

The main magic here is in the implementation of the iterator type (note this code is not from range v3 library).

\begin{box-note}
\begin{cppcode}
// Resume coroutine to generate new value.
void operator++() { 
    coro_.resume(); 
}
// Grab current value from coroutine.
const T& operator*() const {
    return *coro_.promise().current_value;
}
// We are at the end if the coroutine is finished.
bool operator==(std::default_sentinel_t) const { 
    return !coro_ || coro_.done(); 
}
\end{cppcode}
\end{box-note}

The std::default\_sentinel\_t is a convenience type provided by the standard, intended to be used for distinguishing comparisons against the end(). With this, we simply need to return this iterator from the generator<> return type:

\begin{box-note}
\begin{cppcode}
Iter begin() {
    if (coro_) {
        coro_.resume();
    } 
    return Iter{cor_};
}
std::default_sentinel_t end() { 
    return {}; 
}
\end{cppcode}
\end{box-note}

\subsection{Generating using algorithms}

We have quite a few options for the generative approach, the most obvious one being generate\_n that will allow us to generate the output directly.

\begin{box-note}
\begin{cppcode}
ranges::generate_n(
    std::ostream_iterator<std::string>(std::cout, "\n"), 
    20,
    [i = 0]() mutable {
        i++;
        std::string result;
        if (i % 3 == 0) result += "Fizz";
        if (i % 5 == 0) result += "Buzz";
        if (result.empty()) return std::to_string(i);
        return result;
});
\end{cppcode}
\end{box-note}

\subsection{Compositing using views}

Both of the previous approaches are very similar. They both implement FizzBuzz procedurally. However, we can also implement FizzBuzz in a completely different way.

FizzBuzz includes two cycles. Fizz with a period of three and Buzz with a period of five.

\begin{box-note}
\begin{cppcode}
std::array<std::string, 3> fizz{"", "", "Fizz"};
std::array<std::string, 5> buzz{"", "", "", "", "Buzz"};
\end{cppcode}
\end{box-note}

First, we need to turn these cycles into infinite ranges.

\begin{box-note}
\begin{cppcode}
const auto inf_fizz = fizz | ranges::views::cycle;
const auto inf_buzz = buzz | ranges::views::cycle;
\end{cppcode}
\end{box-note}

Then we can combine them using zip\_with:

\begin{box-note}
\begin{cppcode}
const auto inf_fizzbuzz = ranges::views::zip_with(
    std::plus<>(), 
    inf_fizz, 
    inf_buzz);
\end{cppcode}
\end{box-note}

Now we have an infinite range where each 3rd element is “Fizz”, each 5th element is “Buzz”, each 15th element is “FizzBuzz”, and the rest are empty strings.

We are missing the plain numbers for the elements that are neither Fizz of Buzz. So let’s construct an infinite range of indices (starting at one):

\begin{box-note}
\begin{cppcode}
const auto indices = ranges::views::indices
    | ranges::views::drop(1);
\end{cppcode}
\end{box-note}

And finally, we need to put these two ranges together and output the final result.

\begin{box-note}
\begin{cppcode}
const auto final_range = ranges::views::zip_with(
    [](auto i, auto s) { 
        if (s.empty()) return std::to_string(i); 
        return s;
    },
    indices,
    inf_fizzbuzz
);
ranges::copy_n(ranges::begin(final_range), 20,
    std::ostream_iterator<std::string>(std::cout, "\n"));
\end{cppcode}
\end{box-note}